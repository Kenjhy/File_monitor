// Last update transaction car: 2025-07-16 15:12:37.204693
// Total files: 150


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\.azuredevops\modules-pipeline.yaml
/===============================================================================

trigger:
  branches:
    include:
      - master
  paths:
    include:
      - '*'
    exclude:
      - '.azuredevops/*'
      
variables:
  - name: TERRAFORM_DOCS_VERSION
    value: 0.19.0
  - name: DEFAULT_VERSION
    value: 0.0.0
  - name: DEFAULT_BUMP_VERSION_SCHEME
    value: patch
  - name: BRANCH_NAME
    value: $[ replace(variables['Build.SourceBranch'], 'refs/heads/', '') ]

pool:
  vmImage: 'ubuntu-latest'
steps:
  # Check out the code and keep the token so we can tag the repository
  - checkout: self
    persistCredentials: true
    fetchDepth: 0

  # Install terraform-docs.
  - script: |
      #!/bin/bash
      cd "$(Agent.TempDirectory)"
      wget https://github.com/terraform-docs/terraform-docs/releases/download/v$(TERRAFORM_DOCS_VERSION)/terraform-docs-v$(TERRAFORM_DOCS_VERSION)-linux-amd64.tar.gz
      tar -xvf terraform-docs-v$(TERRAFORM_DOCS_VERSION)-linux-amd64.tar.gz
      sudo mv terraform-docs /usr/local/bin/
    displayName: 'Install terraform-docs'

  - script: |
      #!/bin/bash
      DEFAULT_BUMP_VERSION_SCHEME="${{ variables.DEFAULT_BUMP_VERSION_SCHEME }}"
      BUMP_VERSION_SCHEME=$DEFAULT_BUMP_VERSION_SCHEME
      BASE_URL="${SYSTEM_TEAMFOUNDATIONCOLLECTIONURI}${SYSTEM_TEAMPROJECT}"
      BASE_URL=$( echo $BASE_URL | sed 's/ /%20/g' )
      AUTH="Bearer ${ACCESS_TOKEN}"

      PR_URL="${BASE_URL}/_apis/git/repositories/${BUILD_REPOSITORY_ID}/pullrequestquery?api-version=7.1"
      PR_BODY=$( jq -n --arg SHA "$BUILD_SOURCEVERSION" '{ "queries": [{ "items": [ $SHA ], "type": "lastMergeCommit" }] }' )
      PR_RESPONSE=$(curl -s -X POST "${PR_URL}" -H "Content-Type: application/json" -H "Authorization: $AUTH" -d "$PR_BODY")
      PR_RESPONSE=$( echo $PR_RESPONSE | sed 's/\n/\\n/g' )
      PR_RESULT_SIZE=$( echo $PR_RESPONSE | jq -r '.results[0] | length' )

      if [ "$PR_RESULT_SIZE" -gt "0" ]; then
        PULL_REQUEST=$( echo $PR_RESPONSE | jq -r 'first(.results[0][] | . ) | .[0]' )
        PR_ID=$(echo $PULL_REQUEST | jq -r '.pullRequestId')
        PR_LABELS_URL="${BASE_URL}/_apis/git/repositories/${BUILD_REPOSITORY_ID}/pullRequests/${PR_ID}/labels?api-version=7.1"
        PR_LABELS_RESPONSE=$(curl -s -X GET "${PR_LABELS_URL}" -H "Content-Type: application/json" -H "Authorization: $AUTH")

        while read label; do
          if [[ "$label" =~ ^bump:.* ]]; then
            BUMP_VERSION_SCHEME=$( echo $label | sed 's/bump://g' )
            break
          fi
        done < <(echo $PR_LABELS_RESPONSE | jq -r ".value[].name")
      fi

      echo "Bump version scheme: ${BUMP_VERSION_SCHEME}"
      echo "##vso[task.setvariable variable=BUMP_VERSION_SCHEME;]$BUMP_VERSION_SCHEME"
    displayName: 'Get Bump version scheme'
    env:
      ACCESS_TOKEN: $(System.AccessToken)

  - script: |
      #!/bin/bash
      git diff --name-status HEAD~1 HEAD
      MODULES_FILE="$(Agent.TempDirectory)/modules"
      touch $MODULES_FILE
      declare -A MODULES
      while read -r first second third; do        
        FILE="${third}"
        if [[ -z $third ]]; then
          FILE="${second}"
        fi
        if ! [[ "$FILE" =~ ^\.azuredevops.* ]]; then
          DIR=$(dirname $FILE)
          if [[ "$DIR" != "." ]]; then
            if [[ $DIR == */* ]]; then
              DIR=$(echo "$DIR" | cut -d "/" -f1)
            fi
            if [[ -d "$DIR" ]]; then
              MODULES[$DIR]=1
            fi
          fi
        fi
      done < <(git diff --name-status HEAD~1 HEAD)
      if [[ "${#MODULES[@]}" > 0 ]]; then
        printf "%s\n" "${!MODULES[@]}" > $MODULES_FILE
      fi
      echo "##vso[task.setvariable variable=CHANGED_MODULES_FILE;]$MODULES_FILE"
    displayName: 'Get changed modules'

  - script: |
      #!/bin/bash
      CHANGED_MODULES_FILE="$(CHANGED_MODULES_FILE)"
      DEFAULT_VERSION="${{ variables.DEFAULT_VERSION }}"
      SEMVER_REGEX='[^0-9]*\([0-9]*\)[.]\([0-9]*\)[.]\([0-9]*\)\([0-9A-Za-z-]*\)'
      BUMP_VERSION_SCHEME="$(BUMP_VERSION_SCHEME)"

      TAGS_FILE="$(Agent.TempDirectory)/tags"
      touch $TAGS_FILE

      while read MODULE; do
        if ! [[ -d "$MODULE/docs" ]]; then
          mkdir $MODULE/docs
        fi

        if ! [[ -f "$MODULE/docs/header.md" ]]; then
          MODULE_NAME=$(echo $MODULE  | sed 's/[^a-zA-Z0-9]/ /g' | awk '{ print toupper($0) }')
          echo "# ${MODULE_NAME}" > "$MODULE/docs/header.md"
        fi

        if ! [[ -f "$MODULE/docs/version.txt" ]]; then
          echo "${MODULE}/${DEFAULT_VERSION}" > "$MODULE/docs/version.txt"
        fi

        CURRENT_VERSION=$(cat "$MODULE/docs/version.txt")
        CURRENT_VERSION=${CURRENT_VERSION##*/}

        MAJOR=$(echo $CURRENT_VERSION | sed -e "s#$SEMVER_REGEX#\1#")
        MINOR=$(echo $CURRENT_VERSION | sed -e "s#$SEMVER_REGEX#\2#")
        PATCH=$(echo $CURRENT_VERSION | sed -e "s#$SEMVER_REGEX#\3#")

        case "$BUMP_VERSION_SCHEME" in
          major)
            let MAJOR+=1
            let MINOR=0
            let PATCH=0
            ;;
          minor)
            let MINOR+=1
            let PATCH=0
            ;;
          patch)
            let PATCH+=1
            ;;
        esac

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        echo "- Module: $MODULE"
        echo "- Current version: ${CURRENT_VERSION}"
        echo "- New version: ${NEW_VERSION}"

        echo "${MODULE}/${NEW_VERSION}" > "$MODULE/docs/version.txt"
        terraform-docs $MODULE
        echo "---"

        echo "${MODULE}/${NEW_VERSION}" >> $TAGS_FILE

      done < <(cat $CHANGED_MODULES_FILE)
      echo "##vso[task.setvariable variable=TAGS_FILE;]$TAGS_FILE"
    displayName: 'Versioning and documentation'

  - script: |
      #!/bin/bash
      TAGS_FILE="$(TAGS_FILE)"

      git config --local user.email "btg-automation@dev.azure.com"
      git config --local user.name "BTG Automation [bot]"
      git add "*.md"
      git add "*version.txt"
      git commit -m "chore: update module version and documentation [skip ci]"
      git push origin HEAD:$(Build.SourceBranchName)

      while read TAG; do
        echo "Creating tag: ${TAG}"
        git tag $TAG
        git push origin $TAG
      done < <(cat $TAGS_FILE)
    displayName: Git commit, push & tag


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\acm\main.tf
/===============================================================================

resource "aws_acm_certificate" "this" {
  domain_name       = "*.${var.hosted_zone_name}"
  validation_method = "DNS"

  tags = {
    Name = "crt-${var.project}-${var.environment}-${var.hosted_zone_name}"
  }

  lifecycle {
    create_before_destroy = true
  }
}


data "aws_route53_zone" "selected" {
  name         = "${var.hosted_zone_name}."
  private_zone = false
}

resource "aws_route53_record" "this" {
  for_each = {
    for dvo in aws_acm_certificate.this.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      record = dvo.resource_record_value
      type   = dvo.resource_record_type
    }
  }

  allow_overwrite = true
  name            = each.value.name
  records         = [each.value.record]
  ttl             = 60
  type            = each.value.type
  zone_id         = data.aws_route53_zone.selected.zone_id
}

resource "aws_acm_certificate_validation" "this" {
  certificate_arn         = aws_acm_certificate.this.arn
  validation_record_fqdns = [for record in aws_route53_record.this : record.fqdn]
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\acm\outputs.tf
/===============================================================================

output "cert_arn" {
  description = "Certificate ARN"
  value       = aws_acm_certificate.this.arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\acm\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\acm\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 6 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 6 no special characters with no numbers and whitespaces"
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "hosted_zone_name" {
  description = "Hosted zone name"
  type        = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb\main.tf
/===============================================================================

data "aws_route53_zone" "selected" {
  zone_id = var.hosted_zone_id
}

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.service_name}-${var.environment}-lb"
  description = "Allow ALB traffic"
  vpc_id      = var.vpc_id

  ingress {
    from_port        = 80
    to_port          = 80
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }
  

  ingress {
    from_port        = 443
    to_port          = 443
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.service_name}-${var.environment}-lb"
  }
}

resource "aws_lb" "this" {
  name               = "alb-${var.project}-${var.service_name}-${var.environment}"
  internal           = var.public_lb ? false : true
  load_balancer_type = "application"
  security_groups    = [aws_security_group.this.id]
  subnets            = var.subnets

  # access_logs {
  #   bucket  = aws_s3_bucket.lb_logs.id
  #   prefix  = "test-lb"
  #   enabled = true
  # }

  tags = {
    Name = "alb-${var.project}-${var.service_name}-${var.environment}"
  }
}

resource "aws_lb_listener" "http" {
  count             = var.create_http_listener ? 1 : 0
  load_balancer_arn = aws_lb.this.arn
  port              = "80"
  protocol          = "HTTP"

  default_action {
    type = "redirect"

    redirect {
      port        = "443"
      protocol    = "HTTPS"
      status_code = "HTTP_301"
    }
  }
}

resource "aws_lb_listener" "https" {
  count             = var.create_https_listener ? 1 : 0
  load_balancer_arn = aws_lb.this.arn
  port              = "443"
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-2016-08"
  certificate_arn   = var.certificate_arn

  default_action {
    type = "fixed-response"

    fixed_response {
      content_type = "text/plain"
      message_body = "Something goes wrong here"
      status_code  = "404"
    }
  }
}

resource "aws_route53_record" "this" {
  count   = var.create_route53_record ? 1 : 0

  zone_id = data.aws_route53_zone.selected.zone_id
  name    = "${var.service_name}.${chomp(data.aws_route53_zone.selected.name)}"
  type    = "A"

  alias {
    name                   = aws_lb.this.dns_name
    zone_id                = aws_lb.this.zone_id
    evaluate_target_health = true
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb\outputs.tf
/===============================================================================

output "security_group_lb_id" {
  value = aws_security_group.this.id
}

output "lb_dns_name" {
  value = aws_lb.this.dns_name
}

output "http_listener_arn" {
  description = "ARN del listener HTTP"
  value       = length(aws_lb_listener.http) > 0 ? aws_lb_listener.http[0].arn : null
}

output "https_listener_arn" {
  description = "ARN del listener HTTPS"
  value       = length(aws_lb_listener.https) > 0 ? aws_lb_listener.https[0].arn : null
}

output "http_listener_id" {
  description = "ID del listener HTTP"
  value       = length(aws_lb_listener.http) > 0 ? aws_lb_listener.http[0].id : null
}

output "https_listener_id" {
  description = "ID del listener HTTPS"
  value       = length(aws_lb_listener.https) > 0 ? aws_lb_listener.https[0].id : null
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 15 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 15 no special characters with no numbers and whitespaces"
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "public_lb" {
  description = "Is the load balancer public?"
  type        = bool
  default     = true
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "subnets" {
  description = "LB subnets"
  type        = list(string)
}


variable "hosted_zone_id" {
  description = "Hosted zone Id"
  type        = string
}

variable "create_http_listener" {
  description = "Indica si se debe crear el listener HTTP"
  type        = bool
  default     = false
}

variable "create_https_listener" {
  description = "Indica si se debe crear el listener HTTPS"
  type        = bool
  default     = false
}

variable "certificate_arn" {
  description = "ARN del certificado ACM para el listener HTTPS"
  type        = string
  default     = null

  validation {
    condition     = var.create_https_listener == false || (var.create_https_listener == true && var.certificate_arn != null && length(var.certificate_arn) > 0)
    error_message = "Debes proporcionar certificate_arn si create_https_listener es true."
  }
}

variable "create_route53_record" {
  description = "Indica si se debe crear el registro DNS en Route 53 para el ALB"
  type        = bool
  default     = false
}




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb_rules\main.tf
/===============================================================================

resource "aws_lb_listener_rule" "this" {
  count        = length(var.rules)
  listener_arn = var.listener_arn
  priority     = var.rules[count.index].priority

  action {
    type             = "forward"
    target_group_arn = var.rules[count.index].target_group_arn
  }

  condition {
    path_pattern {
      values = [var.rules[count.index].path_pattern]
    }
  }

  tags = {
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb_rules\outputs.tf
/===============================================================================

output "lb_listener_rule_arns" {
  description = "ARNs de las listener rules creadas, para forzar dependencia en ECS service"
  value       = [for r in aws_lb_listener_rule.this : r.arn]
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb_rules\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\alb_rules\variables.tf
/===============================================================================

variable "listener_arn" {
  description = "ARN del listener HTTP/HTTPS del ALB"
  type        = string
}

variable "rules" {
  description = "Lista de reglas a crear con path_pattern, priority y target_group_arn"
  type = list(object({
    path_pattern     = string
    priority         = number
    target_group_arn = string
  }))
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigtw_public_cognito\main.tf
/===============================================================================

# Variables y región
data "aws_region" "current" {}

data "aws_caller_identity" "current" {}

# Cognito User Pool
resource "aws_cognito_user_pool" "this" {
  name = "btgpactual-${var.project}-app"
}

# Cognito User Pool Domain (opcional)
resource "aws_cognito_user_pool_domain" "this" {
  count         = var.enable_cognito_domain ? 1 : 0
  domain        = var.cognito_domain_prefix
  user_pool_id  = aws_cognito_user_pool.this.id

  lifecycle {
    prevent_destroy = false
  }

  depends_on = [aws_cognito_user_pool_client.this]
}

# Cognito User Pool Client
resource "aws_cognito_user_pool_client" "this" {
  name            = "${var.project}-app"
  user_pool_id    = aws_cognito_user_pool.this.id
  generate_secret = var.enable_client_credentials

  allowed_oauth_flows_user_pool_client = var.enable_client_credentials
  allowed_oauth_flows = var.enable_client_credentials ? ["client_credentials"] : []
  allowed_oauth_scopes = var.enable_client_credentials ? flatten([
    for rs in aws_cognito_resource_server.this : [
      for scope in rs.scope : "${rs.identifier}/${scope.scope_name}"
    ]
  ]) : []

  explicit_auth_flows = [
    "ALLOW_ADMIN_USER_PASSWORD_AUTH",
    "ALLOW_REFRESH_TOKEN_AUTH"
  ]

  supported_identity_providers = ["COGNITO"]

  access_token_validity  = var.access_token_validity
  id_token_validity      = var.id_token_validity
  refresh_token_validity = var.refresh_token_validity
  enable_token_revocation = var.enable_token_revocation

  token_validity_units {
    access_token  = "minutes"
    id_token      = "minutes"
    refresh_token = "days"
  }
}

# Cognito Resource Servers
resource "aws_cognito_resource_server" "this" {
  for_each     = var.enable_client_credentials ? { for rs in var.resource_servers : rs.identifier => rs } : {}
  identifier   = each.value.identifier
  name         = each.value.name
  user_pool_id = aws_cognito_user_pool.this.id

  dynamic "scope" {
    for_each = each.value.scopes
    content {
      scope_name        = scope.value.name
      scope_description = scope.value.description
    }
  }
}

# API Gateway
resource "aws_api_gateway_rest_api" "this" {
  name        = "apigw-${var.project}-${var.environment}-public"
  description = "API Public for ${var.project}"

  endpoint_configuration {
    types = ["REGIONAL"]
  }
}

# CloudWatch Log Group for API Gateway
resource "aws_cloudwatch_log_group" "api_gw_logs" {
  name              = "/aws/apigateway/${var.project}-${var.environment}"
  retention_in_days = var.log_retention_days
}

# Enable CloudWatch Logs
resource "aws_api_gateway_account" "this" {
  cloudwatch_role_arn = aws_iam_role.api_gw_logs_role.arn

  depends_on = [aws_iam_role_policy.api_gw_logs_policy]
}

resource "aws_iam_role" "api_gw_logs_role" {
  name = "${var.project}-${var.environment}-apigw-logs-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Effect = "Allow",
      Principal = {
        Service = "apigateway.amazonaws.com"
      },
      Action = "sts:AssumeRole"
    }]
  })
}

resource "aws_iam_role_policy" "api_gw_logs_policy" {
  name = "${var.project}-${var.environment}-apigw-logs-policy"
  role = aws_iam_role.api_gw_logs_role.id

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Effect = "Allow",
      Action = [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:DescribeLogGroups",
        "logs:DescribeLogStreams",
        "logs:PutLogEvents"
      ],
      Resource = "*"
    }]
  })
}

# Cognito Authorizer
resource "aws_api_gateway_authorizer" "cognito" {
  name            = "CognitoAuthorizer"
  rest_api_id     = aws_api_gateway_rest_api.this.id
  identity_source = "method.request.header.Authorization"
  type            = "COGNITO_USER_POOLS"
  provider_arns   = [aws_cognito_user_pool.this.arn]
}

# Dummy endpoint opcional
resource "aws_api_gateway_resource" "dummy" {
  count       = var.enable_dummy_endpoint ? 1 : 0
  rest_api_id = aws_api_gateway_rest_api.this.id
  parent_id   = aws_api_gateway_rest_api.this.root_resource_id
  path_part   = "dummy"
}

resource "aws_api_gateway_method" "dummy_get" {
  count         = var.enable_dummy_endpoint ? 1 : 0
  rest_api_id   = aws_api_gateway_rest_api.this.id
  resource_id   = aws_api_gateway_resource.dummy[0].id
  http_method   = "GET"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "dummy" {
  count                   = var.enable_dummy_endpoint ? 1 : 0
  rest_api_id             = aws_api_gateway_rest_api.this.id
  resource_id             = aws_api_gateway_resource.dummy[0].id
  http_method             = aws_api_gateway_method.dummy_get[0].http_method
  type                    = "MOCK"
  integration_http_method = "GET"
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "dummy_response" {
  count       = var.enable_dummy_endpoint ? 1 : 0
  rest_api_id = aws_api_gateway_rest_api.this.id
  resource_id = aws_api_gateway_resource.dummy[0].id
  http_method = aws_api_gateway_method.dummy_get[0].http_method
  status_code = "200"
}

# Deployment
resource "aws_api_gateway_deployment" "this" {
  rest_api_id = aws_api_gateway_rest_api.this.id
  stage_name  = "disabled-stage-placeholder"

  depends_on = [
    aws_api_gateway_authorizer.cognito,
    aws_api_gateway_method.dummy_get,
    aws_api_gateway_integration.dummy
  ]
}

# Stage para logs
resource "aws_api_gateway_stage" "this" {
  count         = var.create_stage ? 1 : 0
  stage_name    = var.environment
  rest_api_id   = aws_api_gateway_rest_api.this.id
  deployment_id = aws_api_gateway_deployment.this.id

  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_gw_logs.arn
    format = jsonencode({
      requestId       = "$context.requestId",
      ip              = "$context.identity.sourceIp",
      caller          = "$context.identity.caller",
      user            = "$context.identity.user",
      requestTime     = "$context.requestTime",
      httpMethod      = "$context.httpMethod",
      resourcePath    = "$context.resourcePath",
      status          = "$context.status",
      protocol        = "$context.protocol",
      responseLength  = "$context.responseLength"
    })
  }
}

resource "aws_api_gateway_method_settings" "this" {
  rest_api_id = aws_api_gateway_rest_api.this.id
  stage_name  = var.create_stage ? aws_api_gateway_stage.this[0].stage_name : var.environment

  method_path = "*/*"

  settings {
    logging_level      = var.logging_level
    metrics_enabled    = var.enable_method_metrics
    data_trace_enabled = var.enable_data_trace
  }
}



resource "aws_api_gateway_api_key" "default" {
  name        = "${var.project}-${var.environment}-api-key"
  description = "API Key for ${var.project}"
  enabled     = true
}

resource "aws_api_gateway_usage_plan" "default" {
  name = "${var.project}-${var.environment}-usage-plan"

  api_stages {
    api_id = aws_api_gateway_rest_api.this.id
    stage  = var.create_stage ? aws_api_gateway_stage.this[0].stage_name : var.environment
  }  

  quota_settings {
    limit  = 1000
    period = "MONTH"
  }

  throttle_settings {
    rate_limit  = 10
    burst_limit = 2
  }

  depends_on = [
    aws_api_gateway_stage.this
  ]
}

resource "aws_api_gateway_usage_plan_key" "default" {
  key_id        = aws_api_gateway_api_key.default.id
  key_type      = "API_KEY"
  usage_plan_id = aws_api_gateway_usage_plan.default.id
}

# Custom domain base path mapping
resource "aws_api_gateway_base_path_mapping" "custom" {
  count       = var.enable_custom_domain ? 1 : 0
  domain_name = var.custom_domain_name
  api_id      = aws_api_gateway_rest_api.this.id
  stage_name  = var.environment
  base_path   = var.custom_domain_base_path

  depends_on = [aws_api_gateway_deployment.this]
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigtw_public_cognito\outputs.tf
/===============================================================================

output "user_pool_id" {
  description = "ID of the Cognito User Pool"
  value       = aws_cognito_user_pool.this.id
}

output "user_pool_client_id" {
  description = "ID of the Cognito User Pool Client"
  value       = aws_cognito_user_pool_client.this.id
}

output "user_pool_domain" {
  value       = var.enable_cognito_domain ? aws_cognito_user_pool_domain.this[0].domain : null
  description = "Dominio de Cognito si está habilitado"
}

output "api_gateway_id" {
  description = "ID of the API Gateway"
  value       = aws_api_gateway_rest_api.this.id
}

output "api_gateway_invoke_url" {
  description = "Base invoke URL for the API Gateway"
  value       = "https://${aws_api_gateway_rest_api.this.id}.execute-api.${data.aws_region.current.name}.amazonaws.com/${var.environment}"
}

output "api_key_value" {
  description = "Value of the generated API Key"
  value       = aws_api_gateway_api_key.default.value
  sensitive   = true
}

output "resource_server_identifiers" {
  description = "List of Cognito Resource Server identifiers"
  value       = var.enable_client_credentials ? [for rs in aws_cognito_resource_server.this : rs.identifier] : []
}

output "access_token_validity" {
  value       = var.access_token_validity
  description = "Duración del access token en minutos"
}

output "id_token_validity" {
  value       = var.id_token_validity
  description = "Duración del ID token en minutos"
}

output "refresh_token_validity" {
  value       = var.refresh_token_validity
  description = "Duración del refresh token en días"
}

output "enable_token_revocation" {
  value       = var.enable_token_revocation
  description = "Estado de la revocación de tokens"
}

output "api_gateway_stage_name" {
  value = var.create_stage ? aws_api_gateway_stage.this[0].stage_name : null
}




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigtw_public_cognito\providers.tf
/===============================================================================

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigtw_public_cognito\variables.tf
/===============================================================================

variable "project" {
  description = "Nombre del proyecto"
  type        = string
}

variable "environment" {
  description = "Nombre del entorno (dev, prod, etc.)"
  type        = string
}

variable "enable_client_credentials" {
  description = "Indica si se desea habilitar el flujo client_credentials"
  type        = bool
  default     = false
}

variable "resource_servers" {
  description = "Lista de resource servers para Cognito"
  type = list(object({
    identifier = string
    name       = string
    scopes = list(object({
      name        = string
      description = string
    }))
  }))
  default = []
}

variable "enable_cognito_domain" {
  description = "Indica si se debe crear un dominio personalizado para el Cognito User Pool"
  type        = bool
  default     = false
}

variable "cognito_domain_prefix" {
  description = "Prefijo del dominio de Cognito (debe ser único por región)"
  type        = string
  default     = ""
}

variable "enable_dummy_endpoint" {
  description = "Controla si se debe crear el endpoint dummy en API Gateway"
  type        = bool
  default     = false
}


variable "access_token_validity" {
  type        = number
  description = "Duración del access token en minutos"
}

variable "id_token_validity" {
  type        = number
  description = "Duración del ID token en minutos"
}

variable "refresh_token_validity" {
  type        = number
  description = "Duración del refresh token en días"
}

variable "enable_token_revocation" {
  type        = bool
  default     = true
  description = "Habilita la revocación de tokens"
}

variable "enable_custom_domain" {
  type    = bool
  default = false
}

variable "custom_domain_name" {
  type    = string
  default = ""
}

variable "custom_domain_base_path" {
  type    = string
  default = "(none)" # o el path deseado, como "api", "v1", etc.
}

variable "enable_method_metrics" {
  description = "Enable CloudWatch metrics for methods"
  type        = bool
  default     = true
}

variable "enable_data_trace" {
  description = "Enable data trace for method settings"
  type        = bool
  default     = true
}

variable "logging_level" {
  description = "Logging level for API Gateway"
  type        = string
  default     = "INFO"
}

variable "log_retention_days" {
  description = "Cantidad de días para conservar los logs en CloudWatch"
  type        = number
  default     = 30
}

variable "create_stage" {
  description = "Determina si se debe crear el API Gateway Stage"
  type        = bool
  default     = true
}









// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_nlb_integration\main.tf
/===============================================================================


resource "aws_api_gateway_resource" "project_resource" {
  rest_api_id = var.apigw_id
  parent_id   = var.apigw_root_resource_id
  path_part   = var.apigw_project_resource_name
}

resource "aws_api_gateway_resource" "app_resource" {
  rest_api_id = var.apigw_id
  parent_id   = aws_api_gateway_resource.project_resource.id
  path_part   = var.apigw_app_resource_name
}

resource "aws_api_gateway_resource" "proxy_resource" {
  rest_api_id = var.apigw_id
  parent_id   = aws_api_gateway_resource.app_resource.id
  path_part   = "{proxy+}"
}

resource "aws_api_gateway_method" "this" {
  rest_api_id          = var.apigw_id
  resource_id          = aws_api_gateway_resource.proxy_resource.id
  http_method          = "POST"
  authorization        = try(var.authorizer_config.authorization, "NONE")
  authorizer_id        = try(var.authorizer_config.authorizer_id, null)
  authorization_scopes = try(var.authorizer_config.authorization_scopes, null)
  request_parameters = {
    "method.request.path.proxy" = true
  }
}

resource "aws_api_gateway_integration" "this" {
  
  rest_api_id             = var.apigw_id
  resource_id             = aws_api_gateway_resource.proxy_resource.id
  http_method             = aws_api_gateway_method.this.http_method
  type                    = "HTTP_PROXY"
  uri                     = var.integration_uri
  integration_http_method = "POST"
  connection_type         = "VPC_LINK"
  connection_id           = var.aws_api_gateway_vpc_link_id
  request_parameters = {
  "integration.request.path.proxy" = "method.request.path.proxy"
  }
}

resource "aws_api_gateway_method_response" "response_200" {
  rest_api_id = var.apigw_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.this.http_method
  status_code = "200"
  response_models = {
    "application/json" = "Empty"
  }
  
}

resource "aws_api_gateway_deployment" "this" {
  depends_on = [aws_api_gateway_integration.this]
  rest_api_id = var.apigw_id

  triggers = {
    redeployment = sha1(jsonencode([
      aws_api_gateway_resource.project_resource.id,
      aws_api_gateway_resource.app_resource.id,
      aws_api_gateway_resource.proxy_resource.id,
      aws_api_gateway_method.this.id,
      aws_api_gateway_integration.this.id,
    ]))
  }

  lifecycle {
    create_before_destroy = true
  }
}

# resource "aws_api_gateway_stage" "this" {
#   deployment_id = aws_api_gateway_deployment.this.id
#   rest_api_id   = var.apigw_id
#   stage_name    = var.apigw_stage_name
# }



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_nlb_integration\outputs.tf
/===============================================================================




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_nlb_integration\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_nlb_integration\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
}

variable "environment" {
  description = "Project's environment"
  type        = string
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "nlb_arn" {
  description = "Network LoadBalancer ARN"
  type        = string
}

variable "apigw_id" {
  description = "API Gateway ID"
  type        = string
}

variable "apigw_root_resource_id" {
  description = "API Gateway root resource id"
  type        = string
}

variable "apigw_project_resource_name" {
  description = "API Gateway project resource name"
  type        = string
}

variable "apigw_app_resource_name" {
  description = "API Gateway app resource name"
  type        = string
}

variable "integration_uri" {
  description = "Integration URI"
  type        = string
}

variable "apigw_custom_domain_name" {
  description = "API Gateway Custom domain name"
  type        = string
}

variable "apigw_custom_domain_path" {
  description = "API Gateway Custom domain base path"
  type        = string
}

variable "authorizer_config" {
  description = "Authorizer configuration map"
  type        = map(string)
  default = {
    authorization = "None"
  }
}
variable "aws_api_gateway_vpc_link_id" {
  description = "API Gateway VPC Link ID"
  type        = string
}

variable "apigw_stage_name" {
  description = "API Gateway stage name"
  type        = string
  default     = "dev"
  
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_vpc_link\main.tf
/===============================================================================

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.environment}-vpc-link"
  description = "Allow container traffic"
  vpc_id      = var.vpc_id

  ingress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.environment}-vpc-link"
  }
}

resource "aws_apigatewayv2_vpc_link" "this" {
  name               = "apigw-${var.project}-${var.environment}-vpc-link"
  security_group_ids = [aws_security_group.this.id]
  subnet_ids         = var.subnets_ids

  tags = {
    Name = "apigw-${var.project}-${var.environment}-vpc-link"
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_vpc_link\outputs.tf
/===============================================================================

output "vpc_link_id" {
  value = aws_apigatewayv2_vpc_link.this.id
}

output "vpc_link_arn" {
  value = aws_apigatewayv2_vpc_link.this.arn
}

output "vpc_link_security_group_id" {
  value = aws_security_group.this.id
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_vpc_link\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\apigw_vpc_link\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
}

variable "environment" {
  description = "Project's environment"
  type        = string
}

variable "vpc_id" {
  description = "VPC Ids"
  type        = string
}

variable "subnets_ids" {
  description = "Subnets ids for vpc link"
  type        = list(string)
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\cloudfront\main.tf
/===============================================================================

module "cloudfront" {
  source  = "terraform-aws-modules/cloudfront/aws"
  version = "3.4.1"

  for_each = var.items

  aliases                              = try(each.value.aliases, var.defaults.aliases, null)
  comment                              = try(each.value.comment, var.defaults.comment, null)
  continuous_deployment_policy_id      = try(each.value.continuous_deployment_policy_id, var.defaults.continuous_deployment_policy_id, null)
  create_distribution                  = try(each.value.create_distribution, var.defaults.create_distribution, true)
  create_monitoring_subscription       = try(each.value.create_monitoring_subscription, var.defaults.create_monitoring_subscription, false)
  create_origin_access_control         = try(each.value.create_origin_access_control, var.defaults.create_origin_access_control, false)
  create_origin_access_identity        = try(each.value.create_origin_access_identity, var.defaults.create_origin_access_identity, false)
  custom_error_response                = try(each.value.custom_error_response, var.defaults.custom_error_response, {})
  default_cache_behavior               = try(each.value.default_cache_behavior, var.defaults.default_cache_behavior, null)
  default_root_object                  = try(each.value.default_root_object, var.defaults.default_root_object, null)
  enabled                              = try(each.value.enabled, var.defaults.enabled, true)
  geo_restriction                      = try(each.value.geo_restriction, var.defaults.geo_restriction, {})
  http_version                         = try(each.value.http_version, var.defaults.http_version, "http2")
  is_ipv6_enabled                      = try(each.value.is_ipv6_enabled, var.defaults.is_ipv6_enabled, null)
  logging_config                       = try(each.value.logging_config, var.defaults.logging_config, {})
  ordered_cache_behavior               = try(each.value.ordered_cache_behavior, var.defaults.ordered_cache_behavior, [])
  origin                               = try(each.value.origin, var.defaults.origin, null)
  origin_access_control                = try(each.value.origin_access_control, var.defaults.origin_access_control, {})
  origin_access_identities             = try(each.value.origin_access_identities, var.defaults.origin_access_identities, {})
  origin_group                         = try(each.value.origin_group, var.defaults.origin_group, {})
  price_class                          = try(each.value.price_class, var.defaults.price_class, null)
  realtime_metrics_subscription_status = try(each.value.realtime_metrics_subscription_status, var.defaults.realtime_metrics_subscription_status, "Enabled")
  retain_on_delete                     = try(each.value.retain_on_delete, var.defaults.retain_on_delete, false)
  staging                              = try(each.value.staging, var.defaults.staging, false)

  viewer_certificate = try(each.value.viewer_certificate, var.defaults.viewer_certificate, {
    cloudfront_default_certificate = true
    minimum_protocol_version       = "TLSv1"
  })

  wait_for_deployment = try(each.value.wait_for_deployment, var.defaults.wait_for_deployment, true)
  web_acl_id          = try(each.value.web_acl_id, var.defaults.web_acl_id, null)

  tags = try(each.value.tags, var.defaults.tags, null)
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\cloudfront\outputs.tf
/===============================================================================

output "cloudfront_distribution_id" {
  description = "The identifiers for the distributions."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_id }
}

output "cloudfront_distribution_arn" {
  description = "The ARNs (Amazon Resource Names) for the distributions."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_arn }
}

output "cloudfront_distribution_status" {
  description = "The current status of the distribution. Deployed if the distribution's information is fully propagated throughout the Amazon CloudFront system."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_status }
}

output "cloudfront_distribution_trusted_signers" {
  description = "Lists of nested attributes for active trusted signers, for private content with signed URLs."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_trusted_signers }
}

output "cloudfront_distribution_domain_name" {
  description = "The domain names corresponding to the distributions."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_domain_name }
}

output "cloudfront_distribution_last_modified_time" {
  description = "The last modified dates and times for the distributions."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_last_modified_time }
}

output "cloudfront_distribution_etag" {
  description = "The current versions of the distribution information."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_etag }
}

output "cloudfront_distribution_hosted_zone_id" {
  description = "The CloudFront Route 53 zone IDs that can be used for Alias records."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_hosted_zone_id }
}

output "cloudfront_monitoring_subscription_id" {
  description = "The IDs of the CloudFront monitoring subscriptions for each distribution."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_monitoring_subscription_id }
}

output "cloudfront_distribution_tags" {
  description = "Tags for each distribution."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_distribution_tags }
}

output "cloudfront_origin_access_controls" {
  description = "The origin access controls created."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_origin_access_controls }
}

output "cloudfront_origin_access_controls_ids" {
  description = "The IDs of the origin access identities created."
  value       = { for key, v in module.cloudfront : key => v.cloudfront_origin_access_controls_ids }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\cloudfront\providers.tf
/===============================================================================

terraform {
  required_version = "~> 1.3.4"
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\cloudfront\variables.tf
/===============================================================================

variable "items" {
  type    = any
  default = {}
}

variable "defaults" {
  description = "Map of default values which will be used for each item."
  type        = any
  default = {
    create_distribution           = true
    create_origin_access_identity = false
    origin_access_identities      = {}
    create_origin_access_control  = false
    origin_access_control = {
      s3 = {
        description      = "CloudFront Access to S3"
        origin_type      = "s3"
        signing_behavior = "always"
        signing_protocol = "sigv4"
      }
    }
    aliases                         = null
    comment                         = null
    continuous_deployment_policy_id = null
    default_root_object             = null
    enabled                         = true
    http_version                    = "http2"
    is_ipv6_enabled                 = null
    price_class                     = null
    retain_on_delete                = false
    wait_for_deployment             = true
    web_acl_id                      = null
    staging                         = false
    tags                            = null
    origin                          = null
    origin_group                    = {}
    viewer_certificate = {
      cloudfront_default_certificate = true
      minimum_protocol_version       = "TLSv1"
    }
    geo_restriction                      = {}
    logging_config                       = {}
    custom_error_response                = {}
    default_cache_behavior               = null
    ordered_cache_behavior               = []
    create_monitoring_subscription       = false
    realtime_metrics_subscription_status = "Enabled"
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\code_build\main.tf
/===============================================================================

data "aws_region" "current" {}

data "aws_caller_identity" "current" {}

locals {
  aws_region   = data.aws_region.current.name
  account_id   = data.aws_caller_identity.current.account_id
  secrets_arns = distinct([for secret in var.build_secrets_list : secret.valueFrom])
  default_environment_variables = [
    {
      "name" : "ENVIRONMENT",
      "value" : var.environment
    },
    {
      "name" : "PROJECT",
      "value" : var.project
    },
    {
      "name" : "SERVICE",
      "value" : var.service_name
    }
  ]
}

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.service_name}-${var.environment}-build"
  description = "Allow codebuild project traffic"
  vpc_id      = var.vpc_id

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.service_name}-${var.environment}-build"
  }
}

data "aws_iam_policy_document" "codebuild_assume" {
  statement {
    effect  = "Allow"
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["codebuild.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "build_policies" {
  statement {
    sid    = "logsPolicy"
    effect = "Allow"
    actions = [
      "logs:CreateLogGroup",
      "logs:CreateLogStream",
      "logs:PutLogEvents"
    ]
    resources = ["*"]
  }

  statement {
    sid    = "ECRAuth"
    effect = "Allow"
    actions = [
      "ecr:GetAuthorizationToken"
    ]
    resources = ["*"]
  }

  statement {
    sid    = "ECRRepoManagement"
    effect = "Allow"
    actions = [
      "ecr:*"
    ]
    resources = [
      var.ecr_repository_arn
    ]
  }

  statement {
    sid    = "VPCPermissions"
    effect = "Allow"
    actions = [
      "ec2:CreateNetworkInterface",
      "ec2:DescribeDhcpOptions",
      "ec2:DescribeNetworkInterfaces",
      "ec2:DeleteNetworkInterface",
      "ec2:DescribeSubnets",
      "ec2:DescribeSecurityGroups",
      "ec2:DescribeVpcs"
    ]
    resources = [
      "*"
    ]
  }

  statement {
    sid    = "ENIPermissions"
    effect = "Allow"
    actions = [
      "ec2:CreateNetworkInterfacePermission"
    ]
    resources = [
      "arn:aws:ec2:${local.aws_region}:${local.account_id}:network-interface/*"
    ]
    condition {
      test     = "StringEquals"
      variable = "ec2:AuthorizedService"
      values = [
        "codebuild.amazonaws.com"
      ]
    }
  }
}

data "aws_iam_policy_document" "secrets_policy" {
  statement {
    effect = "Allow"
    actions = [
      "secretsmanager:GetSecretValue"
    ]
    resources = local.secrets_arns
  }
}


resource "aws_iam_role" "this" {
  name               = "iam-${var.project}-${var.service_name}-${var.environment}-build-role"
  assume_role_policy = data.aws_iam_policy_document.codebuild_assume.json

  inline_policy {
    name   = "build-policies"
    policy = data.aws_iam_policy_document.build_policies.json
  }

  inline_policy {
    name   = "secrets-policy"
    policy = data.aws_iam_policy_document.secrets_policy.json
  }

  tags = {
    Name = "iam-${var.project}-${var.service_name}-${var.environment}-build-role"
  }
}

resource "aws_codebuild_project" "this" {
  name           = "${var.project}-${var.service_name}-${var.environment}-build"
  description    = "Build project"
  build_timeout  = "20"
  queued_timeout = "30"

  service_role = aws_iam_role.this.arn

  artifacts {
    type = "NO_ARTIFACTS"
  }

  cache {
    type     = "S3"
    location = var.cache_bucket_arn
  }

  environment {
    compute_type                = var.compute_type
    image                       = "aws/codebuild/amazonlinux2-x86_64-standard:4.0"
    type                        = "LINUX_CONTAINER"
    image_pull_credentials_type = "CODEBUILD"
    privileged_mode             = true

    dynamic "environment_variable" {
      for_each = var.build_secrets_list
      iterator = item
      content {
        name  = item.value.name
        value = "${item.value.valueFrom}:${item.value.name}"
        type  = "SECRETS_MANAGER"
      }
    }

    dynamic "environment_variable" {
      for_each = concat(local.default_environment_variables, var.build_environment_variables)
      iterator = item
      content {
        name  = item.value.name
        value = item.value.value
        type  = "PLAINTEXT"
      }
    }
  }

  source {
    type            = "GITHUB"
    location        = var.git_repo_url
    git_clone_depth = 1
    buildspec       = var.buildspec_path
  }

  vpc_config {
    vpc_id  = var.vpc_id
    subnets = var.subnets_list
    security_group_ids = [
      aws_security_group.this.id
    ]
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\code_build\outputs.tf
/===============================================================================

output "codebuild_project_name" {
  value = "${var.project}-${var.service_name}-${var.environment}-build"
}

output "codebuild_project_arn" {
  value = aws_codebuild_project.this.arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\code_build\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\code_build\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 6 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 6 no special characters with no numbers and whitespaces"
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "subnets_list" {
  description = "Subnets ids for codebuild project"
  type        = list(string)
}

variable "ecr_repository_arn" {
  description = "ECR repository ARN"
  type        = string
}

variable "build_secrets_list" {
  description = "Build secrets list"
  type = list(object({
    name      = string
    valueFrom = string
  }))
  default = []
}

variable "build_environment_variables" {
  description = "Build enviroment variables list"
  type = list(object({
    name  = string
    value = string
  }))
  default = []
}

variable "compute_type" {
  description = "Codebuild project compute type"
  type        = string
  default     = "BUILD_GENERAL1_SMALL"
}

variable "cache_bucket_arn" {
  description = "Project cache bucket ARN"
  type        = string
}

variable "git_repo_url" {
  description = "Git repository URL"
  type        = string
}

variable "buildspec_path" {
  description = "Buildspec file path"
  type        = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\codestar\main.tf
/===============================================================================

resource "aws_codestarconnections_connection" "this" {
  name          = "${var.project}-${lower(var.git_provider)}-connection"
  provider_type = var.git_provider
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\codestar\outputs.tf
/===============================================================================

output "connection_arn" {
  value = aws_codestarconnections_connection.this.arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\codestar\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\codestar\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 6 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 6 no special characters with no numbers and whitespaces"
  }
}

variable "git_provider" {
  description = "Git connection provider"
  type        = string
  validation {
    condition     = contains(["GitHub", "GitHubEnterpriseServer", "Bitbucket"], var.git_provider)
    error_message = "The git's provider must to be GitHub, GitHubEnterpriseServer or Bitbucket."
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ddb\main.tf
/===============================================================================

resource "aws_dynamodb_table" "this" {
  name         = var.table_name
  hash_key     = var.hash_key
  billing_mode = var.billing_mode

  dynamic "attribute" {
    for_each = var.attributes
    content {
      name = attribute.value.name
      type = attribute.value.type
    }
  }

  tags = {
    Name = var.table_name
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ddb\outputs.tf
/===============================================================================

output "dynamodb_table_arn" {
  value = aws_dynamodb_table.this.arn
}

output "dynamodb_table_id" {
  value = aws_dynamodb_table.this.id
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ddb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ddb\variables.tf
/===============================================================================

variable "table_name" {
  description = "Table name"
  type        = string
}

variable "hash_key" {
  description = "Table hash key"
  type        = string
}

variable "billing_mode" {
  description = "Table billing mode"
  type        = string
  default     = "PAY_PER_REQUEST"
}

variable "attributes" {
  description = "Table attributes"
  type        = list(object({ name = string, type = string }))
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\docker_build_push\main.tf
/===============================================================================

# build docker image
resource "docker_image" "this" {
  name = "${var.repository_uri}:${var.image_tag}"
  build {
    context = var.build_context
  }
  triggers = {
    dir_sha1 = var.source_sha
  }
}

# push image to ecr repo
resource "docker_registry_image" "this" {
  name          = docker_image.this.name
  keep_remotely = true
  triggers = {
    dir_sha1 = var.source_sha
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\docker_build_push\outputs.tf
/===============================================================================




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\docker_build_push\providers.tf
/===============================================================================

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    docker = {
      source  = "kreuzwerker/docker"
      version = "3.0.2"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\docker_build_push\variables.tf
/===============================================================================

variable "repository_uri" {
  description = "Repository URI"
  type        = string
}

variable "build_context" {
  description = "Docker build context"
  type        = string
}

variable "source_sha" {
  description = "Source code sha"
  type        = string
}

variable "image_tag" {
  description = "Docker image tag"
  type        = string
  default     = "latest"
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\dynamodb\main.tf
/===============================================================================

resource "aws_dynamodb_table" "this" {
  for_each = var.dynamodb_tables

  name         = each.value.name
  hash_key     = each.value.hash_key
  range_key    = each.value.range_key
  billing_mode = each.value.billing_mode

  dynamic "attribute" {
    for_each = toset(concat(
      [each.value.hash_key],
      each.value.range_key != null ? [each.value.range_key] : [],
      flatten([
        for gsi in each.value.gsis != null ? each.value.gsis : [] : concat(
          [gsi.hash_key],
          gsi.range_key != null ? [gsi.range_key] : []
        )
      ])
    ))
    content {
      name = attribute.value
      type = "S"
    }
  }

  # Provisioned throughput solo si se usa "PROVISIONED"
  read_capacity  = each.value.billing_mode == "PROVISIONED" ? each.value.read_capacity : null
  write_capacity = each.value.billing_mode == "PROVISIONED" ? each.value.write_capacity : null

  stream_enabled   = each.value.stream_enabled
  stream_view_type = each.value.stream_enabled ? each.value.stream_view_type : null

  point_in_time_recovery {
    enabled = true
  }

  dynamic "global_secondary_index" {
    for_each = each.value.gsis != null ? each.value.gsis : []
    content {
      name               = global_secondary_index.value.name
      hash_key           = global_secondary_index.value.hash_key
      range_key          = lookup(global_secondary_index.value, "range_key", null)
      projection_type    = global_secondary_index.value.projection_type
      read_capacity      = each.value.billing_mode == "PROVISIONED" ? global_secondary_index.value.read_capacity : null
      write_capacity     = each.value.billing_mode == "PROVISIONED" ? global_secondary_index.value.write_capacity : null
    }
  }

  tags = each.value.tags
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\dynamodb\outputs.tf
/===============================================================================

output "dynamodb_table_names" {
  description = "Nombres de las tablas DynamoDB creadas"
  value = { for k, t in aws_dynamodb_table.this : k => t.name }
}

output "dynamodb_table_arns" {
  description = "ARNs de las tablas DynamoDB creadas"
  value = { for k, t in aws_dynamodb_table.this : k => t.arn }
}

output "dynamodb_table_stream_arns" {
  description = "Stream ARNs de las tablas DynamoDB creadas (si aplica)"
  value = { for k, t in aws_dynamodb_table.this : k => t.stream_enabled ? t.stream_arn : null }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\dynamodb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\dynamodb\variables.tf
/===============================================================================

variable "dynamodb_tables" {
  description = "Mapa de tablas DynamoDB a crear"
  type = map(object({
    name                = string
    hash_key            = string
    range_key           = optional(string)
    billing_mode        = optional(string, "PAY_PER_REQUEST")
    read_capacity       = optional(number, 1)
    write_capacity      = optional(number, 1)
    stream_enabled      = optional(bool, false)
    stream_view_type    = optional(string, "NEW_IMAGE")
    tags                = optional(map(string), {})
    gsis = optional(list(object({
      name            = string
      hash_key        = string
      range_key       = optional(string)
      projection_type = string
      read_capacity   = optional(number)
      write_capacity  = optional(number)
    })), [])
  }))
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecr\main.tf
/===============================================================================

resource "aws_ecr_repository" "this" {

  for_each = { for k, v in var.ecrs : k => v }

  name                 = each.key
  image_tag_mutability = try(each.value.repository_image_tag_mutability, var.repository_image_tag_mutability)

  image_scanning_configuration {
    scan_on_push = try(each.value.repository_image_scan_on_push, var.repository_image_scan_on_push)
  }

  force_delete = try(each.value.repository_force_delete, var.repository_force_delete)

  encryption_configuration {
    encryption_type = try(each.value.repository_encryption_type, var.repository_encryption_type)
    kms_key         = try(each.value.repository_kms_key, var.repository_kms_key)
  }

  tags = merge(var.tags, try(each.value.tags, null))
}

resource "aws_ecr_lifecycle_policy" "this" {

  for_each = { for k, v in var.ecrs : k => v if lookup(v, "lifecycle_policy", null) != null
  && try(length(v.lifecycle_policy) > 0, false) }

  repository = aws_ecr_repository.this[each.key].id
  policy     = jsonencode(each.value.lifecycle_policy)

  depends_on = [aws_ecr_repository.this]
}

resource "aws_ecr_replication_configuration" "this" {
  for_each = { for k, v in var.ecrs : k => v if var.create_registry_replication_configuration }

  replication_configuration {

    dynamic "rule" {
      for_each = var.registry_replication_rules

      content {
        dynamic "destination" {
          for_each = rule.value.destinations

          content {
            region      = destination.value.region
            registry_id = destination.value.registry_id
          }
        }

        dynamic "repository_filter" {
          for_each = try(rule.value.repository_filters, [])

          content {
            filter      = repository_filter.value.filter
            filter_type = repository_filter.value.filter_type
          }
        }
      }
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecr\outputs.tf
/===============================================================================

output "repositories" {
  description = "Provides an Elastic Container Registry Repositories."
  value       = try(flatten(aws_ecr_repository.this[*]), [])
}

output "urls" {
  description = "The URL of the repository (in the form aws_account_id.dkr.ecr.region.amazonaws.com/repositoryName)."
  value       = { for k, v in aws_ecr_repository.this : k => v.repository_url }
}

output "names" {
  description = "The Names of the repository (in the form repositoryname)."
  value       = [for v in aws_ecr_repository.this : v.name]
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecr\variables.tf
/===============================================================================

################################################################################
# Repository 
################################################################################
variable "ecrs" {
  description = "Map of ECRs to create."
  type        = any
  default     = {}
}

variable "repository_force_delete" {
  description = "If 'true', will delete the repository even if it contains images. Defaults to 'false'"
  type        = bool
  default     = false
}

variable "repository_image_tag_mutability" {
  description = "The tag mutability setting for the repository. Must be one of: `MUTABLE` or `IMMUTABLE`. Defaults to `MUTABLE`"
  type        = string
  default     = "MUTABLE"
}

variable "repository_image_scan_on_push" {
  description = "Indicates whether images are scanned after being pushed to the repository (`true`) or not scanned (`false`)"
  type        = bool
  default     = true
}

variable "repository_encryption_type" {
  description = "The encryption type for the repository. Must be one of: `KMS` or `AES256`. Defaults to `AES256`"
  type        = string
  default     = "AES256"
}

variable "repository_kms_key" {
  description = "The ARN of the KMS key to use when encryption_type is `KMS`. If not specified, uses the default AWS managed key for ECR"
  type        = string
  default     = null
}

variable "tags" {
  description = "A mapping of tags to assign to all resources"
  type        = map(string)
  default     = {}
}

################################################################################
# Registry Replication Configuration
################################################################################

variable "create_registry_replication_configuration" {
  description = "Determines whether a registry replication configuration will be created"
  type        = bool
  default     = false
}

variable "registry_replication_rules" {
  description = "The replication rules for a replication configuration. A maximum of 10 are allowed"
  type        = any
  default     = []
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecr\versions.tf
/===============================================================================

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.25"
    }
  }
  required_version = ">= 1.5"
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_cluster\main.tf
/===============================================================================

resource "aws_cloudwatch_log_group" "this" {
  name = "/ecs/cluster/${var.project}/${var.environment}/execute_command_logs"
}

resource "aws_ecs_cluster" "this" {
  name = "ecs-${var.project}-${var.environment}-cluster"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }

  configuration {
    execute_command_configuration {
      # kms_key_id = aws_kms_key.example.arn
      logging = "OVERRIDE"

      log_configuration {
        cloud_watch_encryption_enabled = true
        cloud_watch_log_group_name     = aws_cloudwatch_log_group.this.name
      }
    }
  }
  

  tags = {
    Name = "ecs-${var.project}-${var.environment}-cluster"
  }
}

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.environment}-container-internal"
  description = "Allow internal container communication"
  vpc_id      = var.vpc_id

  ingress {
    description = "Allow internal communication"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    self        = true
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.environment}-container-internal"
  }
}

data "aws_iam_policy_document" "ecs_assume" {
  statement {
    effect  = "Allow"
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ecs-tasks.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "autoscaling_role" {
  name                = "iam-${var.project}-${var.environment}-autoscaling-role"
  assume_role_policy  = data.aws_iam_policy_document.ecs_assume.json
  managed_policy_arns = ["arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole"]

  tags = {
    Name = "iam-${var.project}-${var.environment}-autoscaling-role"
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_cluster\outputs.tf
/===============================================================================

output "cluster_name" {
  value = aws_ecs_cluster.this.name
}

output "cluster_arn" {
  value = aws_ecs_cluster.this.arn
}

output "security_group_internal_id" {
  value = aws_security_group.this.id
}

output "iam_role_autoscaling_name" {
  value = aws_iam_role.autoscaling_role.name
}

output "iam_role_autoscaling_arn" {
  value = aws_iam_role.autoscaling_role.arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_cluster\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_cluster\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 12 && can(regex("^[a-zA-Z-]+$", var.project))
    error_message = "The project's name must to have between 3 and 12 characters only letters or -, no spaces."
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_nlb\main.tf
/===============================================================================

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.environment}-lb"
  description = "Allow LB traffic"
  vpc_id      = var.vpc_id

  tags = {
    Name = "secg-${var.project}-${var.environment}-lb"
  }
}

# Regla para permitir tráfico entrante en el puerto 80
resource "aws_security_group_rule" "allow_http" {
  type              = "ingress"
  from_port         = 80
  to_port           = 80
  protocol          = "tcp"
  cidr_blocks       = ["0.0.0.0/0"]
  ipv6_cidr_blocks  = ["::/0"]
  security_group_id = aws_security_group.this.id
}

# Regla de salida general
resource "aws_security_group_rule" "allow_egress_all" {
  type              = "egress"
  from_port         = 0
  to_port           = 0
  protocol          = "-1"
  cidr_blocks       = ["0.0.0.0/0"]
  ipv6_cidr_blocks  = ["::/0"]
  security_group_id = aws_security_group.this.id
}


resource "aws_lb" "this" {
  name               = "nlb-${var.project}-${var.environment}"
  internal           = var.public_lb ? false : true
  load_balancer_type = "network"
  security_groups    = [aws_security_group.this.id]
  subnets            = var.subnets

  tags = {
    Name = "nlb-${var.project}-${var.environment}"
  }
}

resource "aws_api_gateway_vpc_link" "this" {
  count       = var.enable_vpc_link ? 1 : 0
  name = "apigw-${var.project}-${var.environment}-vpc-link"
  target_arns = [
    aws_lb.this.arn
  ]

  depends_on = [ aws_lb.this ]

}

resource "aws_api_gateway_base_path_mapping" "this" {
  count       = var.enable_api_mapping ? 1 : 0
  api_id      = var.apigw_id
  stage_name  = var.apigw_stage_name
  domain_name = var.apigw_custom_domain_name
  base_path   = var.apigw_custom_domain_path
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_nlb\outputs.tf
/===============================================================================

output "security_group_lb_id" {
  value = aws_security_group.this.id
}

output "lb_arn" {
  value = aws_lb.this.arn
}

output "lb_dns_name" {
  value = aws_lb.this.dns_name
}

output "vpc_link_id" {
  description = "ID del VPC Link (si está habilitado)"
  value       = var.enable_vpc_link ? aws_api_gateway_vpc_link.this[0].id : null
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_nlb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_nlb\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
}

variable "environment" {
  description = "Project's environment"
  type        = string
}

variable "public_lb" {
  description = "Is the load balancer public?"
  type        = bool
  default     = false
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "subnets" {
  description = "LB subnets"
  type        = list(string)
}

variable "apigw_id" {
  description = "API Gateway ID"
  type        = string
}

variable "apigw_custom_domain_name" {
  description = "API Gateway Custom domain name"
  type        = string
}

variable "apigw_custom_domain_path" {
  description = "API Gateway Custom domain base path"
  type        = string
}

variable "apigw_stage_name" {
  description = "API Gateway stage name"
  type        = string
  
}

variable "enable_vpc_link" {
  description = "Habilitar integración con VPC Link"
  type        = bool
  default     = false
}

variable "enable_api_mapping" {
  description = "Habilitar mapeo de base path en API Gateway"
  type        = bool
  default     = false
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service\main.tf
/===============================================================================

data "aws_region" "current" {}

data "aws_caller_identity" "current" {}

data "aws_ecs_cluster" "selected" {
  cluster_name = var.ecs_cluster_name
}

locals {
  aws_region     = data.aws_region.current.name
  account_id     = data.aws_caller_identity.current.account_id
  cluster_arn    = data.aws_ecs_cluster.selected.arn
  log_group_name = "/ecs/service/${var.project}/${var.service_name}/${var.environment}"
  default_container_healthcheck = {
    command     = ["CMD-SHELL", "echo \"Default Health Check\""]
    interval    = 60
    timeout     = 10
    retries     = 3
    startPeriod = 120
  }
}


resource "aws_cloudwatch_log_group" "this" {
  name = local.log_group_name
  tags = {
    Name = local.log_group_name
  }
}

resource "aws_ecs_task_definition" "this" {
  count                    = var.deploy_service ? 1 : 0
  family                   = "ecs-${var.project}-${var.service_name}-${var.environment}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.container_cpu
  memory                   = var.container_ram
  execution_role_arn       = var.execution_role_arn
  task_role_arn            = var.task_role_arn
  container_definitions = jsonencode(
    [
      {
        name      = var.service_name
        image     = "${local.account_id}.dkr.ecr.${local.aws_region}.amazonaws.com/${var.project}/${var.service_name}:${var.image_tag}"
        essential = true
        portMappings = [
          {
            containerPort = var.container_port
          }
        ]
        healthCheck = merge(local.default_container_healthcheck, var.container_healthcheck)
        linuxParameters = {
          InitProcessEnabled = true
        }
        logConfiguration = {
          logDriver = "awslogs"
          options = {
            "awslogs-region"        = local.aws_region
            "awslogs-group"         = local.log_group_name
            "awslogs-stream-prefix" = "ecs"
          }
        }
        environment = var.environment_variables
        secrets     = var.enviroment_secrets
      }
    ]
  )

  tags = {
    Name = "ecs-${var.project}-${var.service_name}-${var.environment}-task"
  }
}

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.service_name}-${var.environment}-ctn"
  description = "Allow container traffic"
  vpc_id      = var.vpc_id

  ingress {
    from_port = var.container_port
    to_port   = var.container_port
    protocol  = "tcp"
    security_groups = [
      var.alb_security_group_id
    ]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.service_name}-${var.environment}-ctn"
  }
}

resource "aws_lb_target_group" "this" {
  name_prefix = substr(var.service_name, 0, 6)
  port        = var.container_port
  protocol    = "TCP"
  target_type = "ip"
  vpc_id      = var.vpc_id
  health_check {
    enabled             = true
    healthy_threshold   = 2
    unhealthy_threshold = 3
    timeout             = 10
    interval            = 30
    protocol            = "TCP"
  }
  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_lb_listener" "tcp" {
  load_balancer_arn = var.lb_listener_arn
  port              = var.listener_port
  protocol          = "TCP"
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.this.arn
  }
}

resource "aws_service_discovery_service" "this" {
  name        = "${var.service_name}-${var.environment}"
  description = "Discovery Service for ${var.project} ${var.service_name} ${var.environment}"
  dns_config {
    namespace_id = var.namespace_id

    dns_records {
      ttl  = 10
      type = "A"
    }

    dns_records {
      ttl  = 10
      type = "SRV"
    }

    routing_policy = "MULTIVALUE"
  }

  health_check_custom_config {
    failure_threshold = 1
  }

  tags = {
    Name = "dsrv-${var.project}-${var.service_name}-${var.environment}"
  }
}

resource "aws_ecs_service" "this" {
  count           = var.deploy_service ? 1 : 0
  name            = "ecs-${var.project}-${var.service_name}-${var.environment}-service"
  depends_on      = [aws_service_discovery_service.this]
  cluster         = local.cluster_arn
  task_definition = aws_ecs_task_definition.this[count.index].arn
  # desired_count   = 3
  enable_execute_command = true

  health_check_grace_period_seconds = 60
  launch_type                       = "FARGATE"

  network_configuration {
    assign_public_ip = false
    security_groups = [
      aws_security_group.this.id,
      var.internal_security_group_id
    ]
    subnets = var.service_subnets_list
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.this.arn
    container_name   = var.service_name
    container_port   = var.container_port
  }

  service_registries {
    registry_arn = aws_service_discovery_service.this.arn
    port         = var.container_port
  }

  tags = {
    Name = "ecs-${var.project}-${var.service_name}-${var.environment}-service"
  }
}


resource "aws_appautoscaling_target" "this" {
  count              = var.deploy_service ? 1 : 0
  max_capacity       = var.autoscaling_max_capacity
  min_capacity       = var.autoscaling_min_capacity
  resource_id        = "service/${var.ecs_cluster_name}/${aws_ecs_service.this[count.index].name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
  role_arn           = var.autoscaling_role_arn
  tags = {
    Name = "aas-${var.project}-${var.service_name}-${var.environment}-ecs-target"
  }
}

resource "aws_appautoscaling_policy" "this" {
  count              = var.deploy_service ? 1 : 0
  name               = "aas-${var.project}-${var.service_name}-${var.environment}-ecs-policy"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.this[count.index].resource_id
  scalable_dimension = aws_appautoscaling_target.this[count.index].scalable_dimension
  service_namespace  = aws_appautoscaling_target.this[count.index].service_namespace

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
    scale_in_cooldown  = 10
    scale_out_cooldown = 10
    target_value       = var.autoscaling_cpu_threshold
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service\outputs.tf
/===============================================================================

output "ecs_task_definition_arn" {
  description = "ARN de la definición de tarea ECS"
  value       = try(aws_ecs_task_definition.this[0].arn, null)
}

output "ecs_service_name" {
  description = "Nombre del servicio ECS"
  value       = try(aws_ecs_service.this[0].name, null)
}

output "ecs_service_security_group_id" {
  description = "ID del security group del contenedor ECS"
  value       = aws_security_group.this.id
}

output "ecs_log_group_name" {
  description = "Nombre del grupo de logs de CloudWatch"
  value       = aws_cloudwatch_log_group.this.name
}

output "ecs_target_group_arn" {
  description = "ARN del target group del load balancer"
  value       = aws_lb_target_group.this.arn
}




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 20 && can(regex("^[a-zA-Z-]+$", var.project))
    error_message = "The project's name must to have between 3 and 20 characters only letters or -, no spaces."
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "deploy_service" {
  description = "Deploy service?"
  type        = bool
  default     = false
}

variable "container_cpu" {
  description = "Container CPU"
  type        = number
}

variable "container_ram" {
  description = "Container RAM"
  type        = number
}

variable "container_port" {
  description = "Container Port"
  type        = number
}

variable "container_healthcheck" {
  description = "Container health check configuration"
  type        = object({ command = list(string), interval = number, timeout = number, retries = number, startPeriod = number })
}

variable "execution_role_arn" {
  description = "Execution role ARN"
  type        = string
}

variable "task_role_arn" {
  description = "Task role ARN"
  type        = string
}

variable "image_tag" {
  description = "Docker image tag"
  type        = string
  default     = "latest"
}

variable "environment_variables" {
  description = "Enviroment variables"
  type        = list(object({ name = string, value = string }))
  default     = []
}

variable "enviroment_secrets" {
  description = "Enviroment variables secrets"
  type        = list(object({ name = string, valueFrom = string }))
  default     = []
}

variable "alb_security_group_id" {
  description = "Load balancer security group id"
  type        = string
}

variable "health_check_path" {
  description = "Health check path"
  type        = string
}

variable "namespace_id" {
  description = "Discovery service namespace id"
  type        = string
}

variable "lb_listener_arn" {
  description = "LB listener ARN"
  type        = string
}

variable "listener_port" {
  description = "LB listener port for service"
  type = number
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "service_subnets_list" {
  description = "Subnets ids for service"
  type        = list(string)
}

variable "autoscaling_min_capacity" {
  description = "Autoscaling min capacity"
  type        = number
  default     = 0
}

variable "autoscaling_max_capacity" {
  description = "Autoscaling max capacity"
  type        = number
  default     = 3
}

variable "internal_security_group_id" {
  description = "Internal communication security group id"
  type        = string
}

variable "ecs_cluster_name" {
  description = "ECS Cluster name"
  type        = string
}

variable "autoscaling_role_arn" {
  description = "Autoscaling role ARN"
  type        = string
}

variable "autoscaling_cpu_threshold" {
  description = "Autoscaling CPU Threshold"
  type        = number
  default     = 80
}





// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service_alb\main.tf
/===============================================================================

data "aws_region" "current" {}

data "aws_caller_identity" "current" {}

data "aws_ecs_cluster" "selected" {
  cluster_name = var.ecs_cluster_name
}

locals {
  aws_region     = data.aws_region.current.name
  account_id     = data.aws_caller_identity.current.account_id
  cluster_arn    = data.aws_ecs_cluster.selected.arn
  log_group_name = "/ecs/service/${var.project}/${var.service_name}/${var.environment}"
  default_container_healthcheck = {
    command     = ["CMD-SHELL", "echo \"Default Health Check\""]
    interval    = 60
    timeout     = 10
    retries     = 3
    startPeriod = 120
  }
}


resource "aws_cloudwatch_log_group" "this" {
  name = local.log_group_name
  tags = {
    Name = local.log_group_name
  }
}

resource "aws_ecs_task_definition" "this" {
  count                    = var.deploy_service ? 1 : 0
  family                   = "ecs-${var.project}-${var.service_name}-${var.environment}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.container_cpu
  memory                   = var.container_ram
  execution_role_arn       = var.execution_role_arn
  task_role_arn            = var.task_role_arn
  container_definitions = jsonencode(
    [
      {
        name      = var.service_name
        image     = "${local.account_id}.dkr.ecr.${local.aws_region}.amazonaws.com/${var.project}/${var.service_name}:${var.image_tag}"
        essential = true
        portMappings = [
          {
            containerPort = var.container_port
          }
        ]
        healthCheck = merge(local.default_container_healthcheck, var.container_healthcheck)
        linuxParameters = {
          InitProcessEnabled = true
        }
        logConfiguration = {
          logDriver = "awslogs"
          options = {
            "awslogs-region"        = local.aws_region
            "awslogs-group"         = local.log_group_name
            "awslogs-stream-prefix" = "ecs"
          }
        }
        environment = var.environment_variables
        secrets     = var.enviroment_secrets
      }
    ]
  )

  tags = {
    Name = "ecs-${var.project}-${var.service_name}-${var.environment}-task"
  }
}

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.service_name}-${var.environment}-ctn"
  description = "Allow container traffic"
  vpc_id      = var.vpc_id

  ingress {
    from_port = var.container_port
    to_port   = var.container_port
    protocol  = "tcp"
    security_groups = [
      var.alb_security_group_id
    ]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.service_name}-${var.environment}-ctn"
  }
}

resource "aws_lb_target_group" "this" {
  name_prefix = substr(var.service_name, 0, 6)
  port        = var.container_port
  protocol    = "HTTP"
  target_type = "ip"
  vpc_id      = var.vpc_id
  health_check {
    enabled             = true
    healthy_threshold   = 2
    unhealthy_threshold = 3
    timeout             = 10
    interval            = 30
    path                = var.health_check_path
    matcher             = "200-399"
    protocol            = "HTTP"
  }
  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_service_discovery_service" "this" {
  name        = "${var.service_name}-${var.environment}"
  description = "Discovery Service for ${var.project} ${var.service_name} ${var.environment}"
  dns_config {
    namespace_id = var.namespace_id

    dns_records {
      ttl  = 10
      type = "A"
    }

    dns_records {
      ttl  = 10
      type = "SRV"
    }

    routing_policy = "MULTIVALUE"
  }

  health_check_custom_config {
    failure_threshold = 1
  }

  tags = {
    Name = "dsrv-${var.project}-${var.service_name}-${var.environment}"
  }
}

resource "aws_ecs_service" "this" {
  count           = var.deploy_service ? 1 : 0
  name            = "ecs-${var.project}-${var.service_name}-${var.environment}-service"
  depends_on      = [aws_service_discovery_service.this,
  var.alb_listener_rule_arns_dependency
  ]
  cluster         = local.cluster_arn
  task_definition = aws_ecs_task_definition.this[count.index].arn
  # desired_count   = 3
  enable_execute_command = true

  health_check_grace_period_seconds = 60
  launch_type                       = "FARGATE"

  network_configuration {
    assign_public_ip = false
    security_groups = [
      aws_security_group.this.id,
      var.internal_security_group_id
    ]
    subnets = var.service_subnets_list
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.this.arn
    container_name   = var.service_name
    container_port   = var.container_port
  }

  service_registries {
    registry_arn = aws_service_discovery_service.this.arn
    port         = var.container_port
  }

  tags = {
    Name = "ecs-${var.project}-${var.service_name}-${var.environment}-service"
  }

}


resource "aws_appautoscaling_target" "this" {
  count              = var.deploy_service ? 1 : 0
  max_capacity       = var.autoscaling_max_capacity
  min_capacity       = var.autoscaling_min_capacity
  resource_id        = "service/${var.ecs_cluster_name}/${aws_ecs_service.this[count.index].name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
  role_arn           = var.autoscaling_role_arn
  tags = {
    Name = "aas-${var.project}-${var.service_name}-${var.environment}-ecs-target"
  }
}

resource "aws_appautoscaling_policy" "this" {
  count              = var.deploy_service ? 1 : 0
  name               = "aas-${var.project}-${var.service_name}-${var.environment}-ecs-policy"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.this[count.index].resource_id
  scalable_dimension = aws_appautoscaling_target.this[count.index].scalable_dimension
  service_namespace  = aws_appautoscaling_target.this[count.index].service_namespace

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
    scale_in_cooldown  = 10
    scale_out_cooldown = 10
    target_value       = var.autoscaling_cpu_threshold
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service_alb\outputs.tf
/===============================================================================

output "ecs_task_definition_arn" {
  description = "ARN de la definición de tarea ECS"
  value       = try(aws_ecs_task_definition.this[0].arn, null)
}

output "ecs_service_name" {
  description = "Nombre del servicio ECS"
  value       = try(aws_ecs_service.this[0].name, null)
}

output "ecs_service_security_group_id" {
  description = "ID del security group del contenedor ECS"
  value       = aws_security_group.this.id
}

output "ecs_log_group_name" {
  description = "Nombre del grupo de logs de CloudWatch"
  value       = aws_cloudwatch_log_group.this.name
}

# output "ecs_target_group_arn" {
#   description = "ARN del target group del load balancer"
#   value       = aws_lb_target_group.this.arn
# }

output "target_group_arn" {
  description = "ARN del Target Group creado para integrarse con el módulo alb-rules."
  value       = aws_lb_target_group.this.arn
}




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service_alb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_service_alb\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 20 && can(regex("^[a-zA-Z-]+$", var.project))
    error_message = "The project's name must to have between 3 and 20 characters only letters or -, no spaces."
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "deploy_service" {
  description = "Deploy service?"
  type        = bool
  default     = false
}

variable "container_cpu" {
  description = "Container CPU"
  type        = number
}

variable "container_ram" {
  description = "Container RAM"
  type        = number
}

variable "container_port" {
  description = "Container Port"
  type        = number
}

variable "container_healthcheck" {
  description = "Container health check configuration"
  type        = object({ command = list(string), interval = number, timeout = number, retries = number, startPeriod = number })
}

variable "execution_role_arn" {
  description = "Execution role ARN"
  type        = string
}

variable "task_role_arn" {
  description = "Task role ARN"
  type        = string
}

variable "image_tag" {
  description = "Docker image tag"
  type        = string
  default     = "latest"
}

variable "environment_variables" {
  description = "Enviroment variables"
  type        = list(object({ name = string, value = string }))
  default     = []
}

variable "enviroment_secrets" {
  description = "Enviroment variables secrets"
  type        = list(object({ name = string, valueFrom = string }))
  default     = []
}

variable "alb_security_group_id" {
  description = "Load balancer security group id"
  type        = string
}

variable "health_check_path" {
  description = "Health check path"
  type        = string
}

variable "namespace_id" {
  description = "Discovery service namespace id"
  type        = string
}


variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "service_subnets_list" {
  description = "Subnets ids for service"
  type        = list(string)
}

variable "autoscaling_min_capacity" {
  description = "Autoscaling min capacity"
  type        = number
  default     = 0
}

variable "autoscaling_max_capacity" {
  description = "Autoscaling max capacity"
  type        = number
  default     = 3
}

variable "internal_security_group_id" {
  description = "Internal communication security group id"
  type        = string
}

variable "ecs_cluster_name" {
  description = "ECS Cluster name"
  type        = string
}

variable "autoscaling_role_arn" {
  description = "Autoscaling role ARN"
  type        = string
}

variable "autoscaling_cpu_threshold" {
  description = "Autoscaling CPU Threshold"
  type        = number
  default     = 80
}

variable "alb_listener_rule_arns_dependency" {
  description = "ARNs de las listener rules para forzar dependencia de creación"
  type        = list(string)
  default     = []
}





// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_task_role\main.tf
/===============================================================================

data "aws_iam_policy_document" "ecs_assume" {
  statement {
    effect  = "Allow"
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ecs-tasks.amazonaws.com"]
    }
  }
}


resource "aws_iam_role" "this" {
  name                = "iam-${var.project}-${var.service_name}-${var.environment}-${var.role_name}"
  assume_role_policy  = data.aws_iam_policy_document.ecs_assume.json
  managed_policy_arns = var.managed_policy_arns
  dynamic "inline_policy" {
    for_each = var.inline_policies
    iterator = item
    content {
      name   = item.value.name
      policy = item.value.policy
    }
  }
  tags = {
    Name = "iam-${var.project}-${var.service_name}-${var.environment}-${var.role_name}"
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_task_role\outputs.tf
/===============================================================================

output "iam_role_name" {
  value = aws_iam_role.this.name
}

output "iam_role_arn" {
  value = aws_iam_role.this.arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_task_role\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ecs_task_role\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 20 && can(regex("^[a-zA-Z-]+$", var.project))
    error_message = "The project's name must to have between 3 and 20 characters only letters or -, no spaces."
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn"
  }
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "role_name" {
  description = "Role name"
  type        = string
}

variable "managed_policy_arns" {
  description = "Managed policy ARNs"
  type        = list(string)
  default     = []
}

variable "inline_policies" {
  description = "Inline policies"
  type        = list(object({ name = string, policy = string }))
  default     = []
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\efs\main.tf
/===============================================================================

################################################################################
# File System
################################################################################

data "aws_kms_alias" "efs" {
  name = "alias/aws/elasticfilesystem"
  # AWS EFS Managed Key
}

resource "aws_efs_file_system" "this" {
  count = var.create ? 1 : 0

  availability_zone_name          = var.availability_zone_name
  creation_token                  = var.creation_token
  performance_mode                = var.performance_mode
  encrypted                       = var.encrypted
  kms_key_id                      = try(var.kms_key_arn, data.aws_kms_alias.efs)
  provisioned_throughput_in_mibps = var.provisioned_throughput_in_mibps
  throughput_mode                 = var.throughput_mode

  dynamic "lifecycle_policy" {
    for_each = [for k, v in var.lifecycle_policy : { (k) = v }]

    content {
      transition_to_ia                    = try(lifecycle_policy.value.transition_to_ia, null)
      transition_to_primary_storage_class = try(lifecycle_policy.value.transition_to_primary_storage_class, null)
    }
  }

  tags = merge(
    var.tags,
    { Name = var.name },
  )
}

################################################################################
# File System Policy
################################################################################

data "aws_iam_policy_document" "policy" {
  count = var.create && var.attach_policy ? 1 : 0

  source_policy_documents   = var.source_policy_documents
  override_policy_documents = var.override_policy_documents

  dynamic "statement" {
    for_each = var.policy_statements

    content {
      sid           = try(statement.value.sid, null)
      actions       = try(statement.value.actions, null)
      not_actions   = try(statement.value.not_actions, null)
      effect        = try(statement.value.effect, null)
      resources     = try(statement.value.resources, [aws_efs_file_system.this[0].arn], null)
      not_resources = try(statement.value.not_resources, null)

      dynamic "principals" {
        for_each = try(statement.value.principals, [])

        content {
          type        = principals.value.type
          identifiers = principals.value.identifiers
        }
      }

      dynamic "not_principals" {
        for_each = try(statement.value.not_principals, [])

        content {
          type        = not_principals.value.type
          identifiers = not_principals.value.identifiers
        }
      }

      dynamic "condition" {
        for_each = try(statement.value.conditions, statement.value.condition, [])

        content {
          test     = condition.value.test
          values   = condition.value.values
          variable = condition.value.variable
        }
      }
    }
  }

  dynamic "statement" {
    for_each = var.deny_nonsecure_transport ? [1] : []

    content {
      sid       = "NonSecureTransport"
      effect    = "Deny"
      actions   = ["*"]
      resources = [aws_efs_file_system.this[0].arn]

      principals {
        type        = "AWS"
        identifiers = ["*"]
      }

      condition {
        test     = "Bool"
        variable = "aws:SecureTransport"
        values   = ["false"]
      }
    }
  }

  dynamic "statement" {
    for_each = var.deny_nonsecure_transport ? [1] : []

    content {
      sid    = "NonSecureTransportAccessedViaMountTarget"
      effect = "Allow"
      actions = [
        "elasticfilesystem:ClientRootAccess",
        "elasticfilesystem:ClientWrite",
        "elasticfilesystem:ClientMount"
      ]
      resources = [aws_efs_file_system.this[0].arn]

      principals {
        type        = "AWS"
        identifiers = ["*"]
      }

      condition {
        test     = "Bool"
        variable = "elasticfilesystem:AccessedViaMountTarget"
        values   = ["true"]
      }
    }
  }
}

resource "aws_efs_file_system_policy" "this" {
  count = var.create && var.attach_policy ? 1 : 0

  file_system_id                     = aws_efs_file_system.this[0].id
  bypass_policy_lockout_safety_check = var.bypass_policy_lockout_safety_check
  policy                             = data.aws_iam_policy_document.policy[0].json
}

################################################################################
# Mount Target(s)
################################################################################

resource "aws_efs_mount_target" "this" {
  for_each = { for k, v in var.mount_targets : k => v if var.create }

  file_system_id  = aws_efs_file_system.this[0].id
  ip_address      = try(each.value.ip_address, null)
  security_groups = var.create_security_group ? concat([aws_security_group.this[0].id], try(each.value.security_groups, [])) : try(each.value.security_groups, null)
  subnet_id       = each.value.subnet_id
}

################################################################################
# Security Group
################################################################################

locals {
  security_group_name = try(coalesce(var.security_group_name, var.name), "")

  create_security_group = var.create && var.create_security_group && length(var.mount_targets) > 0
}

resource "aws_security_group" "this" {
  count = local.create_security_group ? 1 : 0

  name        = var.security_group_use_name_prefix ? null : local.security_group_name
  name_prefix = var.security_group_use_name_prefix ? "${local.security_group_name}-" : null
  description = var.security_group_description

  revoke_rules_on_delete = true
  vpc_id                 = var.security_group_vpc_id

  tags = var.tags

  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_security_group_rule" "this" {
  for_each = { for k, v in var.security_group_rules : k => v if local.create_security_group }

  security_group_id = aws_security_group.this[0].id

  description              = try(each.value.description, null)
  type                     = try(each.value.type, "ingress")
  from_port                = try(each.value.from_port, 2049)
  to_port                  = try(each.value.to_port, 2049)
  protocol                 = try(each.value.protocol, "tcp")
  cidr_blocks              = lookup(each.value, "cidr_blocks", null)
  ipv6_cidr_blocks         = lookup(each.value, "ipv6_cidr_blocks", null)
  prefix_list_ids          = lookup(each.value, "prefix_list_ids", null)
  self                     = try(each.value.self, null)
  source_security_group_id = lookup(each.value, "source_security_group_id", null)

  lifecycle {
    create_before_destroy = true
  }
}

################################################################################
# Access Point(s)
################################################################################

resource "aws_efs_access_point" "this" {
  for_each = { for k, v in var.access_points : k => v if var.create }

  file_system_id = aws_efs_file_system.this[0].id

  dynamic "posix_user" {
    for_each = try([each.value.posix_user], [])

    content {
      gid            = posix_user.value.gid
      uid            = posix_user.value.uid
      secondary_gids = try(posix_user.value.secondary_gids, null)
    }
  }

  dynamic "root_directory" {
    for_each = try([each.value.root_directory], [])

    content {
      path = try(root_directory.value.path, null)

      dynamic "creation_info" {
        for_each = try([root_directory.value.creation_info], [])

        content {
          owner_gid   = creation_info.value.owner_gid
          owner_uid   = creation_info.value.owner_uid
          permissions = creation_info.value.permissions
        }
      }
    }
  }

  tags = merge(
    var.tags,
    try(each.value.tags, {}),
    { Name = try(each.value.name, each.key) },
  )
}

################################################################################
# Backup Policy
################################################################################

resource "aws_efs_backup_policy" "this" {
  count = var.create && var.create_backup_policy ? 1 : 0

  file_system_id = aws_efs_file_system.this[0].id

  backup_policy {
    status = var.enable_backup_policy ? "ENABLED" : "DISABLED"
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\efs\outputs.tf
/===============================================================================

################################################################################
# File System
################################################################################

output "arn" {
  description = "Amazon Resource Name of the file system"
  value       = try(aws_efs_file_system.this[0].arn, null)
}

output "id" {
  description = "The ID that identifies the file system (e.g., `fs-ccfc0d65`)"
  value       = try(aws_efs_file_system.this[0].id, null)
}

output "dns_name" {
  description = "The DNS name for the filesystem per [documented convention](http://docs.aws.amazon.com/efs/latest/ug/mounting-fs-mount-cmd-dns-name.html)"
  value       = try(aws_efs_file_system.this[0].dns_name, null)
}

output "size_in_bytes" {
  description = "The latest known metered size (in bytes) of data stored in the file system, the value is not the exact size that the file system was at any point in time"
  value       = try(aws_efs_file_system.this[0].size_in_bytes, null)
}

################################################################################
# Mount Target(s)
################################################################################

output "mount_targets" {
  description = "Map of mount targets created and their attributes"
  value       = aws_efs_mount_target.this
}

################################################################################
# Security Group
################################################################################

output "security_group_arn" {
  description = "ARN of the security group"
  value       = try(aws_security_group.this[0].arn, null)
}

output "security_group_id" {
  description = "ID of the security group"
  value       = try(aws_security_group.this[0].id, null)
}

################################################################################
# Access Point(s)
################################################################################

output "access_points" {
  description = "Map of access points created and their attributes"
  value       = aws_efs_access_point.this
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\efs\variables.tf
/===============================================================================

variable "create" {
  description = "Determines whether resources will be created (affects all resources)"
  type        = bool
  default     = true
}

variable "name" {
  description = "The name of the file system"
  type        = string
  default     = ""
}

variable "tags" {
  description = "A map of tags to add to all resources"
  type        = map(string)
  default     = {}
}

################################################################################
# File System
################################################################################

variable "availability_zone_name" {
  description = "The AWS Availability Zone in which to create the file system. Used to create a file system that uses One Zone storage classes"
  type        = string
  default     = null
}

variable "creation_token" {
  description = "A unique name (a maximum of 64 characters are allowed) used as reference when creating the Elastic File System to ensure idempotent file system creation. By default generated by Terraform"
  type        = string
  default     = null
}

variable "performance_mode" {
  description = "The file system performance mode. Can be either `generalPurpose` or `maxIO`. Default is `generalPurpose`"
  type        = string
  default     = null
}

variable "encrypted" {
  description = "If `true`, the disk will be encrypted"
  type        = bool
  default     = true
}

variable "kms_key_arn" {
  description = "The ARN for the KMS encryption key. When specifying `kms_key_arn`, encrypted needs to be set to `true`"
  type        = string
  default     = null
}

variable "provisioned_throughput_in_mibps" {
  description = "The throughput, measured in MiB/s, that you want to provision for the file system. Only applicable with `throughput_mode` set to `provisioned`"
  type        = number
  default     = null
}

variable "throughput_mode" {
  description = "Throughput mode for the file system. Defaults to `bursting`. Valid values: `bursting`, `elastic`, and `provisioned`. When using `provisioned`, also set `provisioned_throughput_in_mibps`"
  type        = string
  default     = null
}

variable "lifecycle_policy" {
  description = "A file system [lifecycle policy](https://docs.aws.amazon.com/efs/latest/ug/API_LifecyclePolicy.html) object"
  type        = any
  default     = {}
}

################################################################################
# File System Policy
################################################################################

variable "attach_policy" {
  description = "Determines whether a policy is attached to the file system"
  type        = bool
  default     = true
}

variable "bypass_policy_lockout_safety_check" {
  description = "A flag to indicate whether to bypass the `aws_efs_file_system_policy` lockout safety check. Defaults to `false`"
  type        = bool
  default     = null
}

variable "source_policy_documents" {
  description = "List of IAM policy documents that are merged together into the exported document. Statements must have unique `sid`s"
  type        = list(string)
  default     = []
}

variable "override_policy_documents" {
  description = "List of IAM policy documents that are merged together into the exported document. In merging, statements with non-blank `sid`s will override statements with the same `sid`"
  type        = list(string)
  default     = []
}

variable "policy_statements" {
  description = "A list of IAM policy [statements](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy_document#statement) for custom permission usage"
  type        = any
  default     = []
}

variable "deny_nonsecure_transport" {
  description = "Determines whether `aws:SecureTransport` is required when connecting to elastic file system"
  type        = bool
  default     = true
}

################################################################################
# Mount Target(s)
################################################################################

variable "mount_targets" {
  description = "A map of mount target definitions to create"
  type        = any
  default     = {}
}

################################################################################
# Security Group
################################################################################

variable "create_security_group" {
  description = "Determines whether a security group is created"
  type        = bool
  default     = true
}

variable "security_group_name" {
  description = "Name to assign to the security group. If omitted, Terraform will assign a random, unique name"
  type        = string
  default     = null
}

variable "security_group_description" {
  description = "Security group description. Defaults to Managed by Terraform"
  type        = string
  default     = null
}

variable "security_group_use_name_prefix" {
  description = "Determines whether to use a name prefix for the security group. If `true`, the `security_group_name` value will be used as a prefix"
  type        = bool
  default     = false
}

variable "security_group_vpc_id" {
  description = "The VPC ID where the security group will be created"
  type        = string
  default     = null
}

variable "security_group_rules" {
  description = "Map of security group rule definitions to create"
  type        = any
  default     = {}
}

################################################################################
# Access Point(s)
################################################################################

variable "access_points" {
  description = "A map of access point definitions to create"
  type        = any
  default     = {}
}

################################################################################
# Backup Policy
################################################################################

variable "create_backup_policy" {
  description = "Determines whether a backup policy is created"
  type        = bool
  default     = true
}

variable "enable_backup_policy" {
  description = "Determines whether a backup policy is `ENABLED` or `DISABLED`"
  type        = bool
  default     = true
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\efs\version.tf
/===============================================================================

terraform {
  required_version = ">= 1.3.4"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.42"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\eks\data.tf
/===============================================================================

data "aws_caller_identity" "current" {}
data "aws_availability_zones" "available" {}
data "aws_ami" "eks_default_bottlerocket" {
  most_recent = true
  owners      = ["amazon"]
  filter {
    name   = "name"
    values = ["bottlerocket-aws-k8s-${var.cluster_version}-x86_64-*"]
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\eks\main.tf
/===============================================================================

################################################################################
# EKS Module
################################################################################

module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "20.8.5"

  cluster_name                    = var.cluster_name
  cluster_version                 = var.cluster_version
  cluster_endpoint_private_access = true
  cluster_endpoint_public_access  = false

  cluster_addons = {
    coredns = {
      most_recent = true
    }
    kube-proxy = {
      most_recent = true
    }
    vpc-cni = {
      most_recent = true
    }
  }

  vpc_id                   = var.vpc_id
  subnet_ids               = var.nodegroup_subnet_ids
  control_plane_subnet_ids = var.controlplane_subnet_ids

  cluster_security_group_additional_rules = {
    eks_api_admin_ingress_rule = {
      description = "Allow admin api access"
      protocol    = "-1"
      from_port   = 0
      to_port     = 0
      type        = "ingress"
      cidr_blocks = ["10.26.0.0/15", "10.126.126.0/23"]
    }
  }

  # node_security_group_additional_rules = {
  #   ingress_node_to_node = {
  #     description = "Ingress node to node"
  #     protocol    = "-1"
  #     from_port   = 0
  #     to_port     = 0
  #     type        = "ingress"
  #     self = true
  #   }
  #   ingress_node_to_cluster = {
  #     description = "Ingress node to cluster"
  #     protocol    = "-1"
  #     from_port   = 0
  #     to_port     = 0
  #     type        = "ingress"
  #     source_cluster_security_group = true
  #   }
  # }

  # External encryption key
  create_kms_key = false
  cluster_encryption_config = {
    resources        = ["secrets"]
    provider_key_arn = module.kms.key_arn
  }

  self_managed_node_group_defaults = {
    create_security_group = false
    # enable discovery of autoscaling groups by cluster-autoscaler
    autoscaling_group_tags = {
      "k8s.io/cluster-autoscaler/enabled" : true,
      "k8s.io/cluster-autoscaler/${var.cluster_name}" : "owned",
    }
    # Avoid ASG triggering a regresh and rotating nodes
    instance_refresh = {}
  }

  self_managed_node_groups = {
    # Bottlerocket node group
    main = {
      name = "main-ng-${var.cluster_name}"

      platform      = "bottlerocket"
      ami_id        = data.aws_ami.eks_default_bottlerocket.id
      instance_type = var.primary_nodegroup_settings.instance_type
      desired_size  = var.primary_nodegroup_settings.desired_size
      min_size      = var.primary_nodegroup_settings.min_size
      max_size      = var.primary_nodegroup_settings.max_size
      key_name      = var.key_pair_name

      bootstrap_extra_args = <<-EOT
        # The admin host container provides SSH access and runs with "superpowers".
        # It is disabled by default, but can be disabled explicitly.
        [settings.host-containers.admin]
        enabled = false

        # The control host container provides out-of-band access via SSM.
        # It is enabled by default, and can be disabled if you do not expect to use SSM.
        # This could leave you with no way to access the API and change settings on an existing node!
        [settings.host-containers.control]
        enabled = true

        # extra args added
        [settings.kernel]
        lockdown = "integrity"
      EOT

      iam_role_additional_policies = {
        AmazonSSMManagedInstanceCore = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
      }
    }
  }

  enable_cluster_creator_admin_permissions = true
}

################################################################################
# Supporting Resources
################################################################################


module "kms" {
  source  = "terraform-aws-modules/kms/aws"
  version = "~> 2.1"

  aliases               = ["eks/${var.cluster_name}"]
  description           = "${var.cluster_name} cluster encryption key"
  enable_default_policy = true
  key_owners            = [data.aws_caller_identity.current.arn]
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\eks\outputs.tf
/===============================================================================

output "cluster_endpoint" {
  value = module.eks.cluster_endpoint
}

output "cluster_certificate_authority_data" {
  value = module.eks.cluster_certificate_authority_data
}

output "oidc_provider_arn" {
  value = module.eks.oidc_provider_arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\eks\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_version = ">= 1.6.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.29.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\eks\variables.tf
/===============================================================================

variable "cluster_name" {
  type = string
}

variable "cluster_version" {
  type    = string
  default = "1.29"
}

variable "vpc_id" {
  type = string
}

variable "nodegroup_subnet_ids" {
  type = list(string)
}

variable "controlplane_subnet_ids" {
  type = list(string)
}

variable "primary_nodegroup_settings" {
  type = object({
    instance_type = string
    min_size      = number
    max_size      = number
    desired_size  = number
  })
  default = {
    instance_type = "t3.medium"
    min_size      = 1
    max_size      = 2
    desired_size  = 2
  }
}

variable "key_pair_name" {
  type = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\elasticache\main.tf
/===============================================================================

module "elasticachev2" {
  source  = "terraform-aws-modules/elasticache/aws"
  version = "1.2.2"

  create                      = var.create
  create_cluster              = var.create_cluster
  cluster_id                  = var.cluster_id
  cluster_mode_enabled        = var.cluster_mode_enabled
  num_cache_clusters          = var.num_cache_clusters
  preferred_cache_cluster_azs = var.preferred_cache_cluster_azs

  engine                  = var.engine
  engine_version          = var.engine_version
  port                    = var.port
  node_type               = var.node_type
  num_cache_nodes         = var.num_cache_nodes
  num_node_groups         = var.num_node_groups
  replicas_per_node_group = var.replicas_per_node_group

  network_type = var.network_type
  ip_discovery = var.ip_discovery

  vpc_id                       = var.vpc_id
  create_subnet_group          = var.create_subnet_group
  subnet_group_name            = var.subnet_group_name
  subnet_group_description     = var.subnet_group_description
  subnet_ids                   = var.subnet_ids
  az_mode                      = var.az_mode
  multi_az_enabled             = var.multi_az_enabled
  availability_zone            = var.availability_zone
  preferred_availability_zones = var.preferred_availability_zones

  create_security_group          = var.create_security_group
  security_group_ids             = var.security_group_ids
  security_group_name            = var.security_group_name
  security_group_names           = var.security_group_names
  security_group_use_name_prefix = var.security_group_use_name_prefix
  security_group_description     = var.security_group_description
  security_group_rules           = var.security_group_rules

  create_replication_group                  = var.create_replication_group
  description                               = var.description
  create_primary_global_replication_group   = var.create_primary_global_replication_group
  create_secondary_global_replication_group = var.create_secondary_global_replication_group
  replication_group_id                      = var.replication_group_id
  global_replication_group_id               = var.global_replication_group_id

  at_rest_encryption_enabled = var.at_rest_encryption_enabled
  kms_key_arn                = var.kms_key_arn

  maintenance_window = var.maintenance_window
  apply_immediately  = var.apply_immediately

  auth_token                 = var.auth_token
  auth_token_update_strategy = var.auth_token_update_strategy

  create_parameter_group      = var.create_parameter_group
  parameter_group_name        = var.parameter_group_name
  parameter_group_description = var.parameter_group_description
  parameter_group_family      = var.parameter_group_family
  parameters                  = var.parameters

  notification_topic_arn     = var.notification_topic_arn
  auto_minor_version_upgrade = var.auto_minor_version_upgrade
  automatic_failover_enabled = var.automatic_failover_enabled
  data_tiering_enabled       = var.data_tiering_enabled
  log_delivery_configuration = var.log_delivery_configuration


  outpost_mode          = var.outpost_mode
  preferred_outpost_arn = var.preferred_outpost_arn

  final_snapshot_identifier = var.final_snapshot_identifier
  snapshot_arns             = var.snapshot_arns
  snapshot_name             = var.snapshot_name
  snapshot_retention_limit  = var.snapshot_retention_limit
  snapshot_window           = var.snapshot_window

  transit_encryption_enabled = var.transit_encryption_enabled
  transit_encryption_mode    = var.transit_encryption_mode

  user_group_ids = var.user_group_ids

  security_group_tags = var.security_group_tags
  tags                = var.tags
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\elasticache\outputs.tf
/===============================================================================

################################################################################
# Cluster
################################################################################

output "cluster_arn" {
  description = "The ARN of the ElastiCache Cluster"
  value       = module.elasticachev2.cluster_arn
}

output "cluster_engine_version_actual" {
  description = "Because ElastiCache pulls the latest minor or patch for a version, this attribute returns the running version of the cache engine"
  value       = module.elasticachev2.cluster_engine_version_actual
}

output "cluster_cache_nodes" {
  description = "List of node objects including `id`, `address`, `port` and `availability_zone`"
  value       = module.elasticachev2.cluster_cache_nodes
}

output "cluster_address" {
  description = "(Memcached only) DNS name of the cache cluster without the port appended"
  value       = module.elasticachev2.cluster_address
}

output "cluster_configuration_endpoint" {
  description = "(Memcached only) Configuration endpoint to allow host discovery"
  value       = module.elasticachev2.cluster_configuration_endpoint
}

################################################################################
# Replication Group
################################################################################

output "replication_group_arn" {
  description = "ARN of the created ElastiCache Replication Group"
  value       = module.elasticachev2.replication_group_arn
}

output "replication_group_engine_version_actual" {
  description = "Because ElastiCache pulls the latest minor or patch for a version, this attribute returns the running version of the cache engine"
  value       = module.elasticachev2.replication_group_engine_version_actual
}

output "replication_group_coniguration_endpoint_address" {
  description = "Address of the replication group configuration endpoint when cluster mode is enabled"
  value       = module.elasticachev2.replication_group_coniguration_endpoint_address
}

output "replication_group_id" {
  description = "ID of the ElastiCache Replication Group"
  value       = module.elasticachev2.replication_group_id
}

output "replication_group_member_clusters" {
  description = "Identifiers of all the nodes that are part of this replication group"
  value       = module.elasticachev2.replication_group_member_clusters
}

output "replication_group_primary_endpoint_address" {
  description = "Address of the endpoint for the primary node in the replication group, if the cluster mode is disabled"
  value       = module.elasticachev2.replication_group_primary_endpoint_address
}

output "replication_group_reader_endpoint_address" {
  description = "Address of the endpoint for the reader node in the replication group, if the cluster mode is disabled"
  value       = module.elasticachev2.replication_group_reader_endpoint_address
}

################################################################################
# Global Replication Group
################################################################################

output "global_replication_group_id" {
  description = "ID of the ElastiCache Global Replication Group"
  value       = module.elasticachev2.global_replication_group_id
}

output "global_replication_group_arn" {
  description = "ARN of the created ElastiCache Global Replication Group"
  value       = module.elasticachev2.global_replication_group_arn
}

output "global_replication_group_engine_version_actual" {
  description = "The full version number of the cache engine running on the members of this global replication group"
  value       = module.elasticachev2.global_replication_group_engine_version_actual
}

output "global_replication_group_node_groups" {
  description = "Set of node groups (shards) on the global replication group"
  value       = module.elasticachev2.global_replication_group_node_groups
}

################################################################################
# CloudWatch Log Group
################################################################################

output "cloudwatch_log_group_name" {
  description = "Name of cloudwatch log group created"
  value       = module.elasticachev2.cloudwatch_log_group_name
}

output "cloudwatch_log_group_arn" {
  description = "Arn of cloudwatch log group created"
  value       = module.elasticachev2.cloudwatch_log_group_arn
}

################################################################################
# Parameter Group
################################################################################

output "parameter_group_arn" {
  description = "The AWS ARN associated with the parameter group"
  value       = module.elasticachev2.parameter_group_arn
}

output "parameter_group_id" {
  description = "The ElastiCache parameter group name"
  value       = module.elasticachev2.parameter_group_id
}

################################################################################
# Subnet Group
################################################################################

output "subnet_group_name" {
  description = "The ElastiCache subnet group name"
  value       = module.elasticachev2.subnet_group_name
}

################################################################################
# Security Group
################################################################################

output "security_group_arn" {
  description = "Amazon Resource Name (ARN) of the security group"
  value       = module.elasticachev2.security_group_arn
}

output "security_group_id" {
  description = "ID of the security group"
  value       = module.elasticachev2.security_group_id
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\elasticache\provider.tf
/===============================================================================

terraform {
  required_version = ">= 1.5"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.47"
    }
    random = {
      source  = "hashicorp/random"
      version = ">= 3.0"
    }
  }
}

provider "aws" {
  region = var.region
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\elasticache\variables.tf
/===============================================================================

variable "region" {
  description = "The region you're deploying to"
  type        = string
  default     = "us-east-1"
}

variable "create" {
  description = "Determines whether resources will be created (affects all resources)"
  type        = bool
  default     = true
}

variable "tags" {
  description = "A map of tags to add to all resources"
  type        = map(string)
  default     = {}
}

################################################################################
# Cluster
################################################################################

variable "create_cluster" {
  description = "Determines whether an ElastiCache cluster will be created or not"
  type        = bool
  default     = true
}

variable "apply_immediately" {
  description = "Whether any database modifications are applied immediately, or during the next maintenance window. Default is `false`"
  type        = bool
  default     = null
}

variable "auto_minor_version_upgrade" {
  description = "Specifies whether minor version engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window. Only supported for engine type `redis` and if the engine version is 6 or higher. Defaults to `true`"
  type        = bool
  default     = null
}

variable "automatic_failover_enabled" {
  description = "Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. If true, Multi-AZ is enabled for this replication group. If false, Multi-AZ is disabled for this replication group. Must be enabled for Redis (cluster mode enabled) replication groups"
  type        = bool
  default     = null
}

variable "availability_zone" {
  description = "Availability Zone for the cache cluster. If you want to create cache nodes in multi-az, use `preferred_availability_zones` instead"
  type        = string
  default     = null
}

variable "az_mode" {
  description = "Whether the nodes in this Memcached node group are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. Valid values for this parameter are `single-az` or `cross-az`, default is `single-az`"
  type        = string
  default     = null
}

variable "cluster_id" {
  description = "Group identifier. ElastiCache converts this name to lowercase. Changing this value will re-create the resource"
  type        = string
  default     = ""
}

variable "engine" {
  description = "Name of the cache engine to be used for this cache cluster. Valid values are `memcached` or `redis`"
  type        = string
  default     = "redis"
}

variable "engine_version" {
  description = "Version number of the cache engine to be used. If not set, defaults to the latest version"
  type        = string
  default     = null
}

variable "final_snapshot_identifier" {
  description = "(Redis only) Name of your final cluster snapshot. If omitted, no final snapshot will be made"
  type        = string
  default     = null
}

variable "ip_discovery" {
  description = "The IP version to advertise in the discovery protocol. Valid values are `ipv4` or `ipv6`"
  type        = string
  default     = null
}

variable "log_delivery_configuration" {
  description = "(Redis only) Specifies the destination and format of Redis SLOWLOG or Redis Engine Log"
  type        = any
  default = {
    slow-log = {
      destination_type = "cloudwatch-logs"
      log_format       = "json"
    }
  }
}

variable "maintenance_window" {
  description = "Specifies the weekly time range for when maintenance on the cache cluster is performed. The format is `ddd:hh24:mi-ddd:hh24:mi` (24H Clock UTC)"
  type        = string
  default     = null
}

variable "network_type" {
  description = "The IP versions for cache cluster connections. Valid values are `ipv4`, `ipv6` or `dual_stack`"
  type        = string
  default     = null
}

variable "node_type" {
  description = "The instance class used. For Memcached, changing this value will re-create the resource"
  type        = string
  default     = null
}

variable "notification_topic_arn" {
  description = "ARN of an SNS topic to send ElastiCache notifications to"
  type        = string
  default     = null
}

variable "num_cache_nodes" {
  description = "The initial number of cache nodes that the cache cluster will have. For Redis, this value must be 1. For Memcached, this value must be between 1 and 40. If this number is reduced on subsequent runs, the highest numbered nodes will be removed"
  type        = number
  default     = 1
}

variable "outpost_mode" {
  description = "Specify the outpost mode that will apply to the cache cluster creation. Valid values are `single-outpost` and `cross-outpost`, however AWS currently only supports `single-outpost` mode"
  type        = string
  default     = null
}

variable "port" {
  description = "The port number on which each of the cache nodes will accept connections. For Memcached the default is `11211`, and for Redis the default port is `6379`"
  type        = number
  default     = null
}

variable "preferred_availability_zones" {
  description = "List of the Availability Zones in which cache nodes are created"
  type        = list(string)
  default     = []
}

variable "preferred_outpost_arn" {
  description = "(Required if `outpost_mode` is specified) The outpost ARN in which the cache cluster will be created"
  type        = string
  default     = null
}

variable "security_group_ids" {
  description = "One or more VPC security groups associated with the cache cluster"
  type        = list(string)
  default     = []
}

variable "snapshot_arns" {
  description = "(Redis only) Single-element string list containing an Amazon Resource Name (ARN) of a Redis RDB snapshot file stored in Amazon S3"
  type        = list(string)
  default     = []
}

variable "snapshot_name" {
  description = "(Redis only) Name of a snapshot from which to restore data into the new node group. Changing `snapshot_name` forces a new resource"
  type        = string
  default     = null
}

variable "snapshot_retention_limit" {
  description = "(Redis only) Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them"
  type        = number
  default     = null
}

variable "snapshot_window" {
  description = "(Redis only) Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. Example: `05:00-09:00`"
  type        = string
  default     = null
}

variable "transit_encryption_enabled" {
  description = "Enable encryption in-transit. Supported only with Memcached versions `1.6.12` and later, running in a VPC"
  type        = bool
  default     = true
}

variable "transit_encryption_mode" {
  description = "A setting that enables clients to migrate to in-transit encryption with no downtime. Valid values are preferred and required"
  type        = string
  default     = null
}

################################################################################
# Replication Group
################################################################################

variable "create_replication_group" {
  description = "Determines whether an ElastiCache replication group will be created or not"
  type        = bool
  default     = true
}

variable "auth_token" {
  description = "The password used to access a password protected server. Can be specified only if `transit_encryption_enabled = true`"
  type        = string
  default     = null
}

variable "auth_token_update_strategy" {
  description = "Strategy to use when updating the `auth_token`. Valid values are `SET`, `ROTATE`, and `DELETE`. Defaults to `ROTATE`"
  type        = string
  default     = null
}

variable "at_rest_encryption_enabled" {
  description = "Whether to enable encryption at rest"
  type        = bool
  default     = true
}

variable "data_tiering_enabled" {
  description = "Enables data tiering. Data tiering is only supported for replication groups using the `r6gd` node type. This parameter must be set to true when using `r6gd` nodes"
  type        = bool
  default     = null
}

variable "description" {
  description = "User-created description for the replication group"
  type        = string
  default     = null
}

variable "global_replication_group_id" {
  description = "The ID of the global replication group to which this replication group should belong"
  type        = string
  default     = null
}

variable "kms_key_arn" {
  description = "The ARN of the key that you wish to use if encrypting at rest. If not supplied, uses service managed encryption. Can be specified only if `at_rest_encryption_enabled = true`"
  type        = string
  default     = null
}

variable "multi_az_enabled" {
  description = "Specifies whether to enable Multi-AZ Support for the replication group. If true, `automatic_failover_enabled` must also be enabled. Defaults to `false`"
  type        = bool
  default     = false
}

variable "num_cache_clusters" {
  description = "Number of cache clusters (primary and replicas) this replication group will have. If Multi-AZ is enabled, the value of this parameter must be at least 2. Updates will occur before other modifications. Conflicts with `num_node_groups`. Defaults to `1`"
  type        = number
  default     = null
}

variable "num_node_groups" {
  description = "Number of node groups (shards) for this Redis replication group. Changing this number will trigger a resizing operation before other settings modifications"
  type        = number
  default     = null
}

variable "preferred_cache_cluster_azs" {
  description = "List of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is considered. The first item in the list will be the primary node. Ignored when updating"
  type        = list(string)
  default     = []
}

variable "replicas_per_node_group" {
  description = "Number of replica nodes in each node group. Changing this number will trigger a resizing operation before other settings modifications. Valid values are 0 to 5"
  type        = number
  default     = null
}

variable "replication_group_id" {
  description = "Replication group identifier. When `create_replication_group` is set to `true`, this is the ID assigned to the replication group created. When `create_replication_group` is set to `false`, this is the ID of an externally created replication group"
  type        = string
  default     = null
}

variable "security_group_names" {
  description = "Names of one or more Amazon VPC security groups associated with this replication group"
  type        = list(string)
  default     = []
}

variable "user_group_ids" {
  description = "User Group ID to associate with the replication group. Only a maximum of one (1) user group ID is valid"
  type        = list(string)
  default     = null
}

variable "cluster_mode_enabled" {
  description = "Whether to enable Redis [cluster mode https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Replication.Redis-RedisCluster.html]"
  type        = bool
  default     = false
}

################################################################################
# Global Replication Group
################################################################################

variable "create_primary_global_replication_group" {
  description = "Determines whether an primary ElastiCache global replication group will be created"
  type        = bool
  default     = false
}

variable "create_secondary_global_replication_group" {
  description = "Determines whether an secondary ElastiCache global replication group will be created"
  type        = bool
  default     = false
}

################################################################################
# Parameter Group
################################################################################

variable "create_parameter_group" {
  description = "Determines whether the ElastiCache parameter group will be created or not"
  type        = bool
  default     = false
}

variable "parameter_group_description" {
  description = "The description of the ElastiCache parameter group. Defaults to `Managed by Terraform`"
  type        = string
  default     = null
}

variable "parameter_group_family" {
  description = "The family of the ElastiCache parameter group"
  type        = string
  default     = ""
}

variable "parameter_group_name" {
  description = "The name of the parameter group. If `create_parameter_group` is `true`, this is the name assigned to the parameter group created. Otherwise, this is the name of an existing parameter group"
  type        = string
  default     = null
}

variable "parameters" {
  description = "List of ElastiCache parameters to apply"
  type        = list(map(string))
  default     = []
}

################################################################################
# Subnet Group
################################################################################

variable "create_subnet_group" {
  description = "Determines whether the Elasticache subnet group will be created or not"
  type        = bool
  default     = true
}

variable "subnet_group_name" {
  description = "The name of the subnet group. If `create_subnet_group` is `true`, this is the name assigned to the subnet group created. Otherwise, this is the name of an existing subnet group"
  type        = string
  default     = null
}

variable "subnet_group_description" {
  description = "Description for the Elasticache subnet group"
  type        = string
  default     = null
}

variable "subnet_ids" {
  description = "List of VPC Subnet IDs for the Elasticache subnet group"
  type        = list(string)
  default     = []
}

################################################################################
# Security Group
################################################################################

variable "create_security_group" {
  description = "Determines if a security group is created"
  type        = bool
  default     = true
}

variable "security_group_name" {
  description = "Name to use on security group created"
  type        = string
  default     = null
}

variable "security_group_use_name_prefix" {
  description = "Determines whether the security group name (`security_group_name`) is used as a prefix"
  type        = bool
  default     = true
}

variable "security_group_description" {
  description = "Description of the security group created"
  type        = string
  default     = null
}

variable "vpc_id" {
  description = "Identifier of the VPC where the security group will be created"
  type        = string
  default     = null
}

variable "security_group_rules" {
  description = "Security group ingress and egress rules to add to the security group created"
  type        = any
  default     = {}
}

variable "security_group_tags" {
  description = "A map of additional tags to add to the security group created"
  type        = map(string)
  default     = {}
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\lambda\main.tf
/===============================================================================


# Image based Lambda function
resource "aws_lambda_function" "vmd_lambda_func" {
  function_name                  = var.function_name
  memory_size                    = var.memory_size
  role                           = var.role_arn
  timeout                        = var.timeout
  publish                        = var.publish
  reserved_concurrent_executions = var.reserved_concurrent_executions
  image_uri                      = var.image_uri
  package_type                   = "Image"


  # Define any environment variables required by the Lambda function
  environment {
    variables = var.environment_variables
  }

  # Define any VPC settings required by the Lambda function
  vpc_config {
    subnet_ids         = var.subnet_ids
    security_group_ids = var.security_group_ids
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\lambda\outputs.tf
/===============================================================================

output "lambda_function_arn" {
  description = "The ARN of the created Lambda function."
  value       = aws_lambda_function.vmd_lambda_func.arn
}

output "lambda_function_name" {
  description = "The name of the created Lambda function."
  value       = aws_lambda_function.vmd_lambda_func.function_name
}

output "lambda_function_invoke_arn" {
  description = "The ARN that can be used to invoke the Lambda function."
  value       = aws_lambda_function.vmd_lambda_func.invoke_arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\lambda\variables.tf
/===============================================================================

variable "publish" {
  description = "Flag to publish as a new version or overwrite."
  type        = bool
  default     = false
}

variable "reserved_concurrent_executions" {
  description = "The amount of reserved concurrent executions for this lambda function. A value of 0 disables lambda from being triggered and -1 removes any concurrency limitations."
  type        = number
  default     = -1
}

variable "function_name" {
  description = "The name of the Lambda function."
  type        = string
  default     = "vmd-lambda-function"
}

variable "memory_size" {
  description = "(Optional) Amount of memory in MB your Lambda Function can use at runtime. Defaults to 128."
  type        = number
  default     = 128
}

variable "role_arn" {
  description = "The ARN of the IAM role that AWS Lambda assumes when it executes the function."
  type        = string
  default     = ""
}

variable "timeout" {
  description = "The amount of time that AWS Lambda allows a function to run before stopping it."
  type        = number
  default     = 60
}

variable "image_uri" {
  description = "The image uri of the function"
  type        = string
  default     = ""
}

variable "environment_variables" {
  description = "A map of environment variables to set for the Lambda function."
  type        = map(string)
  default     = {}
}

variable "subnet_ids" {
  description = "A list of IDs of the subnets in which to create the Lambda function."
  type        = list(string)
  default     = []
}

variable "security_group_ids" {
  description = "A list of IDs of the security groups for the Lambda function."
  type        = list(string)
  default     = []
}




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\lambda\versions.tf
/===============================================================================

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.36"
    }
  }
  required_version = "~> 1.5.0"
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\network\main.tf
/===============================================================================

resource "aws_vpc" "this" {
  cidr_block           = var.cird_block
  instance_tenancy     = "default"
  enable_dns_support   = true
  enable_dns_hostnames = true
  tags = {
    Name = "vpc-${var.project}-${var.environment}"
  }
}

resource "aws_internet_gateway" "this" {
  vpc_id = aws_vpc.this.id

  tags = {
    Name = "igw-${var.project}-${var.environment}"
  }
}


resource "aws_subnet" "public" {
  count             = length(var.availability_zones)
  vpc_id            = aws_vpc.this.id
  cidr_block        = var.public_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  tags = {
    Name = "snet-${var.project}-${var.environment}-pub0${count.index + 1}"
  }
}

resource "aws_subnet" "private" {
  count             = length(var.availability_zones)
  vpc_id            = aws_vpc.this.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  tags = {
    Name = "snet-${var.project}-${var.environment}-prv0${count.index + 1}"
  }
}

resource "aws_subnet" "secure" {
  count             = length(var.availability_zones)
  vpc_id            = aws_vpc.this.id
  cidr_block        = var.secure_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  tags = {
    Name = "snet-${var.project}-${var.environment}-sec0${count.index + 1}"
  }
}

resource "aws_eip" "this" {
  count      = length(var.availability_zones)
  depends_on = [aws_internet_gateway.this]
  tags = {
    Name = "eip-${var.project}-${var.environment}-0${count.index + 1}"
  }
}

resource "aws_nat_gateway" "this" {
  count         = length(var.availability_zones)
  depends_on    = [aws_internet_gateway.this]
  allocation_id = aws_eip.this.*.id[count.index]
  subnet_id     = aws_subnet.public.*.id[count.index]
  tags = {
    Name = "ngw-${var.project}-${var.environment}-0${count.index + 1}"
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.this.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.this.id
  }

  tags = {
    Name = "pubrt-${var.project}-${var.environment}"
  }
}

resource "aws_route_table_association" "public" {
  count          = length(var.availability_zones)
  subnet_id      = aws_subnet.public.*.id[count.index]
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table" "private" {
  count  = length(var.availability_zones)
  vpc_id = aws_vpc.this.id
  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.this.*.id[count.index]
  }

  tags = {
    Name = "prvrt-${var.project}-${var.environment}-0${count.index + 1}"
  }
}

resource "aws_route_table_association" "private" {
  count          = length(var.availability_zones)
  subnet_id      = aws_subnet.private.*.id[count.index]
  route_table_id = aws_route_table.private.*.id[count.index]
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\network\outputs.tf
/===============================================================================

output "vpc_id" {
  description = "VPC Id"
  value       = aws_vpc.this.id
}

output "subnet_public_ids" {
  value = aws_subnet.public.*.id
}

output "subnet_private_ids" {
  value = aws_subnet.private.*.id
}

output "subnet_secure_ids" {
  value = aws_subnet.secure.*.id
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\network\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\network\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 6 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 6 no special characters with no numbers and whitespaces"
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "cird_block" {
  description = "Network CIDR block"
  type        = string
  validation {
    condition     = can(regex("(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})", var.cird_block))
    error_message = "The CIDR must to be a valid network address with mask"
  }
}

variable "availability_zones" {
  description = "Availability zones"
  type        = list(string)
}

variable "public_subnet_cidrs" {
  description = "Public subnets CIDR"
  type        = list(string)
}

variable "private_subnet_cidrs" {
  description = "Private subnets CIDR"
  type        = list(string)
}

variable "secure_subnet_cidrs" {
  description = "Secure subnets CIDR"
  type        = list(string)
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb\main.tf
/===============================================================================

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.environment}-lb"
  description = "Allow LB traffic"
  vpc_id      = var.vpc_id

  ingress {
    from_port        = 80
    to_port          = 80
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.environment}-lb"
  }
}

resource "aws_lb_target_group" "this" {
  name_prefix = substr(var.service_name, 0, 6)
  port        = var.container_port
  protocol    = "TCP"
  target_type = "ip"
  vpc_id      = var.vpc_id
  health_check {
    enabled             = true
    healthy_threshold   = 2
    unhealthy_threshold = 3
    timeout             = 10
    interval            = 30
    protocol            = "TCP"
  }
  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_lb" "this" {
  name               = "nlb-${var.project}-${var.environment}"
  internal           = var.public_lb ? false : true
  load_balancer_type = "network"
  security_groups    = [aws_security_group.this.id]
  subnets            = var.subnets

  tags = {
    Name = "nlb-${var.project}-${var.environment}"
  }
}

resource "aws_lb_listener" "tcp" {
  load_balancer_arn = aws_lb.this.arn
  port              = "80"
  protocol          = "TCP"

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.this.arn
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb\outputs.tf
/===============================================================================

output "security_group_lb_id" {
  value = aws_security_group.this.id
}

output "lb_arn" {
  value = aws_lb.this.arn
}

output "lb_listener_arn" {
  value = aws_lb_listener.tcp.arn
}

output "lb_dns_name" {
  value = aws_lb.this.dns_name
}

output "target_group_arn" {
  value = aws_lb_target_group.this.arn
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
}

variable "environment" {
  description = "Project's environment"
  type        = string
}

variable "service_name" {
  description = "Service name"
  type        = string
}

variable "public_lb" {
  description = "Is the load balancer public?"
  type        = bool
  default     = false
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "subnets" {
  description = "LB subnets"
  type        = list(string)
}

variable "container_port" {
  description = "Container port"
  type        = number
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb-alb\main.tf
/===============================================================================

### Crea NLB ####

resource "aws_security_group" "this" {
  name        = "secg-${var.project}-${var.environment}-lb"
  description = "Allow LB traffic"
  vpc_id      = var.vpc_id

  tags = {
    Name = "secg-${var.project}-${var.environment}-lb"
  }
}

# Regla para permitir tráfico entrante en el puerto 80
resource "aws_security_group_rule" "allow_http" {
  type              = "ingress"
  from_port         = 80
  to_port           = 80
  protocol          = "tcp"
  cidr_blocks       = ["0.0.0.0/0"]
  ipv6_cidr_blocks  = ["::/0"]
  security_group_id = aws_security_group.this.id
}

# Regla de salida general
resource "aws_security_group_rule" "allow_egress_all" {
  type              = "egress"
  from_port         = 0
  to_port           = 0
  protocol          = "-1"
  cidr_blocks       = ["0.0.0.0/0"]
  ipv6_cidr_blocks  = ["::/0"]
  security_group_id = aws_security_group.this.id
}


resource "aws_lb" "this" {
  name               = "nlb-${var.project}-${var.environment}"
  internal           = var.public_lb ? false : true
  load_balancer_type = "network"
  security_groups    = [aws_security_group.this.id]
  subnets            = var.subnets

  tags = {
    Name = "nlb-${var.project}-${var.environment}"
  }
}

resource "aws_api_gateway_vpc_link" "this" {
  count       = var.enable_vpc_link ? 1 : 0
  name = "apigw-${var.project}-${var.environment}-vpc-link"
  target_arns = [
    aws_lb.this.arn
  ]
}

resource "aws_api_gateway_base_path_mapping" "this" {
  count       = var.enable_api_mapping ? 1 : 0
  api_id      = var.apigw_id
  stage_name  = var.apigw_stage_name
  domain_name = var.apigw_custom_domain_name
  base_path   = var.apigw_custom_domain_path
}



# Creación ALB

data "aws_route53_zone" "selected" {
  zone_id = var.hosted_zone_id
}

resource "aws_security_group" "alb" {
  name        = "secg-${var.project}-${var.service_name}-${var.environment}-alb"
  description = "Allow ALB traffic"
  vpc_id      = var.vpc_id

  ingress {
    from_port        = 80
    to_port          = 80
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }
  
  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = "secg-${var.project}-${var.service_name}-${var.environment}-lb"
  }
}

resource "aws_alb" "this" {
  name               = "alb-${var.project}-${var.environment}"
  internal           = var.public_lb ? false : true
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = var.subnets

  # access_logs {
  #   bucket  = aws_s3_bucket.lb_logs.id
  #   prefix  = "test-lb"
  #   enabled = true
  # }

  tags = {
    Name = "alb-${var.project}-${var.service_name}-${var.environment}"
  }
}

resource "aws_lb_listener" "http" {
  count             = var.create_http_listener ? 1 : 0
  load_balancer_arn = aws_alb.this.arn
  port              = "80"
  protocol          = "HTTP"

  default_action {
    type = "fixed-response"

    fixed_response {
      content_type = "text/plain"
      message_body = "Fixed response content"
      status_code  = "200"
    }
  }
}

resource "aws_route53_record" "this" {
  count   = var.create_route53_record ? 1 : 0

  zone_id = data.aws_route53_zone.selected.zone_id
  name    = "${var.service_name}.${chomp(data.aws_route53_zone.selected.name)}"
  type    = "A"

  alias {
    name                   = aws_alb.this.dns_name
    zone_id                = aws_alb.this.zone_id
    evaluate_target_health = true
  }
}


# Target Group del NLB
resource "aws_lb_target_group" "this" {
  name_prefix = substr(var.service_name, 0, 6)
  port        = 80
  protocol    = "TCP"
  target_type = "alb"
  vpc_id      = var.vpc_id
  health_check {
    enabled             = true
    healthy_threshold   = 2
    unhealthy_threshold = 3
    timeout             = 10
    interval            = 30
    protocol            = "HTTP"
  }

  lifecycle {
    create_before_destroy = true
  }
}

# attach ALB al target group del NLB
resource "aws_lb_target_group_attachment" "test" {
  target_group_arn = aws_lb_target_group.this.arn
  target_id        = aws_alb.this.id
  port             = 80
}

resource "aws_lb_listener" "tcp" {
  load_balancer_arn = aws_lb.this.arn
  port              = "80"
  protocol          = "TCP"

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.this.arn
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb-alb\outputs.tf
/===============================================================================

output "security_group_nlb_id" {
  value = aws_security_group.this.id
}

output "security_group_alb_id" {
  value = aws_security_group.alb.id
}

output "lb_arn" {
  value = aws_lb.this.arn
}

output "lb_dns_name" {
  value = aws_lb.this.dns_name
}

output "vpc_link_id" {
  description = "ID del VPC Link (si está habilitado)"
  value       = var.enable_vpc_link ? aws_api_gateway_vpc_link.this[0].id : null
}


output "http_listener_arn" {
  description = "ARN del listener HTTP"
  value       = length(aws_lb_listener.http) > 0 ? aws_lb_listener.http[0].arn : null
}


output "http_listener_id" {
  description = "ID del listener HTTP"
  value       = length(aws_lb_listener.http) > 0 ? aws_lb_listener.http[0].id : null
}




// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb-alb\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\nlb-alb\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
}

variable "environment" {
  description = "Project's environment"
  type        = string
}

variable "public_lb" {
  description = "Is the load balancer public?"
  type        = bool
  default     = false
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "subnets" {
  description = "LB subnets"
  type        = list(string)
}

variable "apigw_id" {
  description = "API Gateway ID"
  type        = string
}

variable "apigw_custom_domain_name" {
  description = "API Gateway Custom domain name"
  type        = string
}

variable "apigw_custom_domain_path" {
  description = "API Gateway Custom domain base path"
  type        = string
}

variable "apigw_stage_name" {
  description = "API Gateway stage name"
  type        = string
  
}

variable "enable_vpc_link" {
  description = "Habilitar integración con VPC Link"
  type        = bool
  default     = false
}

variable "enable_api_mapping" {
  description = "Habilitar mapeo de base path en API Gateway"
  type        = bool
  default     = false
}

variable "hosted_zone_id" {
  description = "Hosted zone Id"
  type        = string
}

variable "create_http_listener" {
  description = "Indica si se debe crear el listener HTTP"
  type        = bool
  default     = false
}

variable "create_route53_record" {
  description = "Indica si se debe crear el registro DNS en Route 53 para el ALB"
  type        = bool
  default     = false
}

variable "service_name" {
  description = "Service name"
  type        = string
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\private_hosted_zone\main.tf
/===============================================================================

resource "aws_route53_zone" "this" {
  name = var.hosted_zone_name
  vpc {
    vpc_id = var.vpc_id
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\private_hosted_zone\outputs.tf
/===============================================================================

output "hosted_zone_id" {
  value = aws_route53_zone.this.zone_id
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\private_hosted_zone\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_version = ">= 1.6.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\private_hosted_zone\variables.tf
/===============================================================================

variable "hosted_zone_name" {
  type = string
}

variable "vpc_id" {
  type = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds\main.tf
/===============================================================================

################################################
########## RDS Module Implementation ###########
################################################
module "rds" {
  source  = "terraform-aws-modules/rds/aws"
  version = "6.10.0"

  create_db_instance          = var.create_db_instance
  create_db_option_group      = var.create_db_option_group
  create_db_subnet_group      = var.create_db_subnet_group
  create_db_parameter_group   = var.create_db_parameter_group
  create_monitoring_role      = var.create_monitoring_role
  create_cloudwatch_log_group = var.create_cloudwatch_log_group

  identifier                     = var.identifier
  instance_use_identifier_prefix = var.instance_use_identifier_prefix

  engine               = var.engine
  engine_version       = var.engine_version
  major_engine_version = var.major_engine_version
  instance_class       = var.instance_class
  allocated_storage    = var.allocated_storage
  storage_type         = var.storage_type
  storage_encrypted    = var.storage_encrypted
  kms_key_id           = var.kms_key_id
  license_model        = var.license_model

  db_name                             = var.db_name
  username                            = var.username
  password                            = var.password
  port                                = var.port
  domain                              = var.domain
  domain_auth_secret_arn              = var.domain_auth_secret_arn
  domain_dns_ips                      = var.domain_dns_ips
  domain_fqdn                         = var.domain_fqdn
  domain_iam_role_name                = var.domain_iam_role_name
  domain_ou                           = var.domain_ou
  iam_database_authentication_enabled = var.iam_database_authentication_enabled
  custom_iam_instance_profile         = var.custom_iam_instance_profile
  manage_master_user_password         = var.manage_master_user_password
  master_user_secret_kms_key_id       = var.master_user_secret_kms_key_id

  manage_master_user_password_rotation                   = var.manage_master_user_password_rotation
  master_user_password_rotate_immediately                = var.master_user_password_rotate_immediately
  master_user_password_rotation_automatically_after_days = var.master_user_password_rotation_automatically_after_days
  master_user_password_rotation_duration                 = var.master_user_password_rotation_duration
  master_user_password_rotation_schedule_expression      = var.master_user_password_rotation_schedule_expression

  vpc_security_group_ids          = [try(module.security_group_rds.security_group_id, var.vpc_security_group_ids, null)]
  db_subnet_group_name            = var.database_subnet_group
  db_subnet_group_use_name_prefix = var.db_subnet_group_use_name_prefix
  db_subnet_group_description     = var.db_subnet_group_description
  option_group_name               = var.option_group_name
  option_group_use_name_prefix    = var.option_group_use_name_prefix
  option_group_description        = var.option_group_description
  option_group_timeouts           = var.option_group_timeouts
  network_type                    = var.network_type

  availability_zone   = var.availability_zone
  multi_az            = var.multi_az
  iops                = var.iops
  storage_throughput  = var.storage_throughput
  publicly_accessible = var.publicly_accessible
  ca_cert_identifier  = var.ca_cert_identifier

  allow_major_version_upgrade = var.allow_major_version_upgrade
  auto_minor_version_upgrade  = var.auto_minor_version_upgrade
  apply_immediately           = var.apply_immediately
  maintenance_window          = var.maintenance_window
  blue_green_update           = var.blue_green_update

  snapshot_identifier              = var.snapshot_identifier
  copy_tags_to_snapshot            = var.copy_tags_to_snapshot
  skip_final_snapshot              = var.skip_final_snapshot
  final_snapshot_identifier_prefix = var.final_snapshot_identifier_prefix

  performance_insights_enabled          = var.performance_insights_enabled
  performance_insights_retention_period = var.performance_insights_retention_period
  performance_insights_kms_key_id       = var.performance_insights_kms_key_id

  replicate_source_db                  = var.replicate_source_db
  replica_mode                         = var.replica_mode
  backup_retention_period              = var.backup_retention_period
  backup_window                        = var.backup_window
  max_allocated_storage                = var.max_allocated_storage
  monitoring_interval                  = var.monitoring_interval
  monitoring_role_arn                  = var.monitoring_role_arn
  monitoring_role_name                 = var.monitoring_role_name
  monitoring_role_use_name_prefix      = var.monitoring_role_use_name_prefix
  monitoring_role_description          = var.monitoring_role_description
  monitoring_role_permissions_boundary = var.monitoring_role_permissions_boundary

  character_set_name       = var.character_set_name
  nchar_character_set_name = var.nchar_character_set_name
  timezone                 = var.timezone

  enabled_cloudwatch_logs_exports        = var.enabled_cloudwatch_logs_exports
  cloudwatch_log_group_retention_in_days = var.cloudwatch_log_group_retention_in_days
  cloudwatch_log_group_kms_key_id        = var.cloudwatch_log_group_kms_key_id

  timeouts = var.timeouts

  deletion_protection      = var.deletion_protection
  delete_automated_backups = var.delete_automated_backups

  restore_to_point_in_time = var.restore_to_point_in_time
  s3_import                = var.s3_import

  db_instance_tags = var.db_instance_tags

  parameters = var.parameters

  options = var.options

  subnet_ids = var.subnet_ids

  db_instance_role_associations = var.db_instance_role_associations

  parameter_group_name            = var.parameter_group_name
  parameter_group_use_name_prefix = var.parameter_group_use_name_prefix
  parameter_group_description     = var.parameter_group_description
  family                          = var.family


  db_parameter_group_tags = var.db_parameter_group_tags
  db_option_group_tags    = var.db_option_group_tags
  db_subnet_group_tags    = var.db_subnet_group_tags
  tags                    = var.tags
}

################################################
########### SG Module Implementation ###########
################################################
module "security_group_rds" {
  source  = "terraform-aws-modules/security-group/aws"
  version = "~> 5.0"

  name        = var.sg_name
  description = "PostgreSQL security group for ${var.identifier} engine"
  vpc_id      = var.sg_vpc_id

  # ingress
  ingress_with_cidr_blocks = var.ingress_with_cidr_blocks

  # egress
  egress_with_cidr_blocks = var.egress_with_cidr_blocks

  tags = var.sg_tags
}

################################################
######## Route 53 Records Implementation ########
################################################
module "records" {

  source  = "terraform-aws-modules/route53/aws//modules/records"
  version = "4.1.0"

  create       = var.create_record
  zone_name    = var.zone_name
  private_zone = true
  records = [
    {
      name            = var.record_name
      type            = "CNAME"
      ttl             = var.record_ttl
      allow_overwrite = true
      records = [
        module.rds.db_instance_address
      ]
    }
  ]
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds\outputs.tf
/===============================================================================

output "db_instance_address" {
  description = "The address of the RDS instance"
  value       = module.rds.db_instance_address
}

output "db_instance_arn" {
  description = " The ARN of the RDS instance"
  value       = module.rds.db_instance_arn
}

output "db_instance_availability_zone" {
  description = "The availability zone of the RDS instance"
  value       = module.rds.db_instance_availability_zone
}

output "db_instance_ca_cert_identifier" {
  description = "Specifies the identifier of the CA certificate for the DB instance"
  value       = module.rds.db_instance_ca_cert_identifier
}

output "db_instance_cloudwatch_log_groups" {
  description = "Map of CloudWatch log groups created and their attributes"
  value       = module.rds.db_instance_cloudwatch_log_groups
}

output "db_instance_domain" {
  description = "The ID of the Directory Service Active Directory domain the instance is joined to"
  value       = module.rds.db_instance_domain
}

output "db_instance_domain_auth_secret_arn" {
  description = " The ARN for the Secrets Manager secret with the self managed Active Directory credentials for the user joining the domain"
  value       = module.rds.db_instance_domain_auth_secret_arn
}

output "db_instance_domain_dns_ips" {
  description = "The IPv4 DNS IP addresses of your primary and secondary self managed Active Directory domain controllers"
  value       = module.rds.db_instance_domain_dns_ips
}

output "db_instance_domain_fqdn" {
  description = "The fully qualified domain name (FQDN) of an self managed Active Directory domain"
  value       = module.rds.db_instance_domain_fqdn
}

output "db_instance_domain_iam_role_name" {
  description = "The name of the IAM role to be used when making API calls to the Directory Service"
  value       = module.rds.db_instance_domain_iam_role_name
}

output "db_instance_domain_ou" {
  description = "The self managed Active Directory organizational unit for your DB instance to join"
  value       = module.rds.db_instance_domain_ou
}

output "db_instance_endpoint" {
  description = "The connection endpoint"
  value       = module.rds.db_instance_endpoint
}

output "db_instance_engine" {
  description = "The database engine"
  value       = module.rds.db_instance_engine
}

output "db_instance_engine_version_actual" {
  description = "The running version of the database"
  value       = module.rds.db_instance_engine_version_actual
}

output "db_instance_hosted_zone_id" {
  description = "The canonical hosted zone ID of the DB instance (to be used in a Route 53 Alias record)"
  value       = module.rds.db_instance_hosted_zone_id
}

output "db_instance_identifier" {
  description = "The RDS instance identifier"
  value       = module.rds.db_instance_identifier
}

output "db_instance_master_user_secret_arn" {
  description = "The ARN of the master user secret (Only available when manage_master_user_password is set to true)"
  value       = module.rds.db_instance_master_user_secret_arn
}

output "db_instance_name" {
  description = "The database name"
  value       = module.rds.db_instance_name
}

output "db_instance_port" {
  description = "The database port"
  value       = module.rds.db_instance_port
}

output "db_instance_resource_id" {
  description = "The RDS Resource ID of this instance"
  value       = module.rds.db_instance_resource_id
}

output "db_instance_role_associations" {
  description = "A map of DB Instance Identifiers and IAM Role ARNs separated by a comma"
  value       = module.rds.db_instance_role_associations
}

output "db_instance_secretsmanager_secret_rotation_enabled" {
  description = "Specifies whether automatic rotation is enabled for the secret"
  value       = module.rds.db_instance_secretsmanager_secret_rotation_enabled
}

output "db_instance_status" {
  description = "The RDS instance status"
  value       = module.rds.db_instance_status
}

output "db_instance_username" {
  description = "The master username for the database"
  value       = module.rds.db_instance_username
}

output "db_listener_endpoint" {
  description = "Specifies the listener connection endpoint for SQL Server Always On"
  value       = module.rds.db_listener_endpoint
}

output "db_option_group_arn" {
  description = "The ARN of the db option group"
  value       = module.rds.db_option_group_arn
}

output "db_option_group_id" {
  description = "The db option group id"
  value       = module.rds.db_option_group_id
}

output "db_parameter_group_arn" {
  description = "The ARN of the db parameter group"
  value       = module.rds.db_parameter_group_arn
}

output "db_parameter_group_id" {
  description = "The db parameter group id"
  value       = module.rds.db_parameter_group_id
}

output "db_subnet_group_arn" {
  description = "The ARN of the db subnet group"
  value       = module.rds.db_subnet_group_arn
}

output "db_subnet_group_id" {
  description = "The db subnet group name"
  value       = module.rds.db_subnet_group_id
}

output "enhanced_monitoring_iam_role_arn" {
  description = "The Amazon Resource Name (ARN) specifying the monitoring role"
  value       = module.rds.enhanced_monitoring_iam_role_arn
}

output "enhanced_monitoring_iam_role_name" {
  description = "The name of the monitoring role"
  value       = module.rds.enhanced_monitoring_iam_role_name
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds\provider.tf
/===============================================================================

terraform {
  required_version = ">= 1.5"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.36"
    }
  }
}

provider "aws" {
  region = var.region
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds\variables.tf
/===============================================================================

################################################################################
# General Vars
################################################################################
variable "region" {
  description = "Database Region"
  type        = string
  default     = null
}
################################################################################
# RDS Module Vars 
################################################################################
variable "identifier" {
  description = "The name of the RDS instance"
  type        = string
}

variable "instance_use_identifier_prefix" {
  description = "Determines whether to use `identifier` as is or create a unique identifier beginning with `identifier` as the specified prefix"
  type        = bool
  default     = false
}

variable "custom_iam_instance_profile" {
  description = "RDS custom iam instance profile"
  type        = string
  default     = null
}

variable "allocated_storage" {
  description = "The allocated storage in gigabytes"
  type        = number
  default     = null
}

variable "storage_type" {
  description = "One of 'standard' (magnetic), 'gp2' (general purpose SSD), 'gp3' (new generation of general purpose SSD), or 'io1' (provisioned IOPS SSD). The default is 'io1' if iops is specified, 'gp2' if not. If you specify 'io1' or 'gp3' , you must also include a value for the 'iops' parameter"
  type        = string
  default     = null
}

variable "storage_throughput" {
  description = "Storage throughput value for the DB instance. See `notes` for limitations regarding this variable for `gp3`"
  type        = number
  default     = null
}

variable "storage_encrypted" {
  description = "Specifies whether the DB instance is encrypted"
  type        = bool
  default     = true
}

variable "kms_key_id" {
  description = "The ARN for the KMS encryption key. If creating an encrypted replica, set this to the destination KMS ARN. If storage_encrypted is set to true and kms_key_id is not specified the default KMS key created in your account will be used. Be sure to use the full ARN, not a key alias."
  type        = string
  default     = null
}

variable "replicate_source_db" {
  description = "Specifies that this resource is a Replicate database, and to use this value as the source database. This correlates to the identifier of another Amazon RDS Database to replicate"
  type        = string
  default     = null
}

variable "license_model" {
  description = "License model information for this DB instance. Optional, but required for some DB engines, i.e. Oracle SE1"
  type        = string
  default     = null
}

variable "replica_mode" {
  description = "Specifies whether the replica is in either mounted or open-read-only mode. This attribute is only supported by Oracle instances. Oracle replicas operate in open-read-only mode unless otherwise specified"
  type        = string
  default     = null
}

variable "iam_database_authentication_enabled" {
  description = "Specifies whether or not the mappings of AWS Identity and Access Management (IAM) accounts to database accounts are enabled"
  type        = bool
  default     = false
}

variable "domain" {
  description = "The ID of the Directory Service Active Directory domain to create the instance in"
  type        = string
  default     = null
}

variable "domain_auth_secret_arn" {
  description = "(Optional, but required if domain_fqdn is provided) The ARN for the Secrets Manager secret with the self managed Active Directory credentials for the user joining the domain. Conflicts with domain and domain_iam_role_name."
  type        = string
  default     = null
}

variable "domain_dns_ips" {
  description = "(Optional, but required if domain_fqdn is provided) The IPv4 DNS IP addresses of your primary and secondary self managed Active Directory domain controllers. Two IP addresses must be provided. If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list. Conflicts with domain and domain_iam_role_name."
  type        = list(string)
  default     = null
}

variable "domain_fqdn" {
  description = "The fully qualified domain name (FQDN) of the self managed Active Directory domain. Conflicts with domain and domain_iam_role_name."
  type        = string
  default     = null
}

variable "domain_iam_role_name" {
  description = "(Required if domain is provided) The name of the IAM role to be used when making API calls to the Directory Service"
  type        = string
  default     = null
}

variable "domain_ou" {
  description = "(Optional, but required if domain_fqdn is provided) The self managed Active Directory organizational unit for your DB instance to join. Conflicts with domain and domain_iam_role_name."
  type        = string
  default     = null
}

variable "engine" {
  description = "The database engine to use"
  type        = string
  default     = null
}

variable "engine_version" {
  description = "The engine version to use"
  type        = string
  default     = null
}

variable "skip_final_snapshot" {
  description = "Determines whether a final DB snapshot is created before the DB instance is deleted. If true is specified, no DBSnapshot is created. If false is specified, a DB snapshot is created before the DB instance is deleted"
  type        = bool
  default     = false
}

variable "snapshot_identifier" {
  description = "Specifies whether or not to create this database from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05"
  type        = string
  default     = null
}

variable "copy_tags_to_snapshot" {
  description = "On delete, copy all Instance tags to the final snapshot"
  type        = bool
  default     = false
}

variable "final_snapshot_identifier_prefix" {
  description = "The name which is prefixed to the final snapshot on cluster destroy"
  type        = string
  default     = "final"
}

variable "instance_class" {
  description = "The instance type of the RDS instance"
  type        = string
  default     = null
}

variable "db_name" {
  description = "The DB name to create. If omitted, no database is created initially"
  type        = string
  default     = null
}

variable "username" {
  description = "Username for the master DB user"
  type        = string
  default     = null
}

variable "password" {
  description = <<EOF
  Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file.
  The password provided will not be used if `manage_master_user_password` is set to true.
  EOF
  type        = string
  default     = null
  sensitive   = true
}

variable "manage_master_user_password" {
  description = "Set to true to allow RDS to manage the master user password in Secrets Manager"
  type        = bool
  default     = true
}

variable "master_user_secret_kms_key_id" {
  description = <<EOF
  The key ARN, key ID, alias ARN or alias name for the KMS key to encrypt the master user password secret in Secrets Manager.
  If not specified, the default KMS key for your Amazon Web Services account is used.
  EOF
  type        = string
  default     = null
}

variable "port" {
  description = "The port on which the DB accepts connections"
  type        = string
  default     = null
}

variable "vpc_security_group_ids" {
  description = "List of VPC security groups to associate"
  type        = list(string)
  default     = []
}

variable "availability_zone" {
  description = "The Availability Zone of the RDS instance"
  type        = string
  default     = null
}

variable "multi_az" {
  description = "Specifies if the RDS instance is multi-AZ"
  type        = bool
  default     = false
}

variable "database_subnet_group" {
  description = "Database Subnet Group"
  type        = string
  default     = null
}

variable "iops" {
  description = "The amount of provisioned IOPS. Setting this implies a storage_type of 'io1' or `gp3`. See `notes` for limitations regarding this variable for `gp3`"
  type        = number
  default     = null
}

variable "publicly_accessible" {
  description = "Bool to control if instance is publicly accessible"
  type        = bool
  default     = false
}

variable "monitoring_interval" {
  description = "The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60"
  type        = number
  default     = 0
}

variable "monitoring_role_arn" {
  description = "The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. Must be specified if monitoring_interval is non-zero"
  type        = string
  default     = null
}

variable "monitoring_role_name" {
  description = "Name of the IAM role which will be created when create_monitoring_role is enabled"
  type        = string
  default     = "rds-monitoring-role"
}

variable "monitoring_role_use_name_prefix" {
  description = "Determines whether to use `monitoring_role_name` as is or create a unique identifier beginning with `monitoring_role_name` as the specified prefix"
  type        = bool
  default     = false
}

variable "monitoring_role_description" {
  description = "Description of the monitoring IAM role"
  type        = string
  default     = null
}

variable "create_monitoring_role" {
  description = "Create IAM role with a defined name that permits RDS to send enhanced monitoring metrics to CloudWatch Logs"
  type        = bool
  default     = false
}

variable "monitoring_role_permissions_boundary" {
  description = "ARN of the policy that is used to set the permissions boundary for the monitoring IAM role"
  type        = string
  default     = null
}

variable "allow_major_version_upgrade" {
  description = "Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible"
  type        = bool
  default     = false
}

variable "auto_minor_version_upgrade" {
  description = "Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window"
  type        = bool
  default     = true
}

variable "apply_immediately" {
  description = "Specifies whether any database modifications are applied immediately, or during the next maintenance window"
  type        = bool
  default     = false
}

variable "maintenance_window" {
  description = "The window to perform maintenance in. Syntax: 'ddd:hh24:mi-ddd:hh24:mi'. Eg: 'Mon:00:00-Mon:03:00'"
  type        = string
  default     = null
}

variable "blue_green_update" {
  description = "Enables low-downtime updates using RDS Blue/Green deployments."
  type        = map(string)
  default     = {}
}

variable "backup_retention_period" {
  description = "The days to retain backups for"
  type        = number
  default     = null
}

variable "backup_window" {
  description = "The daily time range (in UTC) during which automated backups are created if they are enabled. Example: '09:46-10:16'. Must not overlap with maintenance_window"
  type        = string
  default     = null
}

variable "restore_to_point_in_time" {
  description = "Restore to a point in time (MySQL is NOT supported)"
  type        = map(string)
  default     = null
}

variable "s3_import" {
  description = "Restore from a Percona Xtrabackup in S3 (only MySQL is supported)"
  type        = map(string)
  default     = null
}

variable "tags" {
  description = "A mapping of tags to assign to all resources"
  type        = map(string)
  default     = {}
}

variable "db_instance_tags" {
  description = "Additional tags for the DB instance"
  type        = map(string)
  default     = {}
}

variable "db_option_group_tags" {
  description = "Additional tags for the DB option group"
  type        = map(string)
  default     = {}
}

variable "db_parameter_group_tags" {
  description = "Additional tags for the  DB parameter group"
  type        = map(string)
  default     = {}
}

variable "db_subnet_group_tags" {
  description = "Additional tags for the DB subnet group"
  type        = map(string)
  default     = {}
}

# DB subnet group
variable "create_db_subnet_group" {
  description = "Whether to create a database subnet group"
  type        = bool
  default     = false
}

variable "db_subnet_group_use_name_prefix" {
  description = "Determines whether to use `subnet_group_name` as is or create a unique name beginning with the `subnet_group_name` as the prefix"
  type        = bool
  default     = true
}

variable "db_subnet_group_description" {
  description = "Description of the DB subnet group to create"
  type        = string
  default     = null
}

variable "subnet_ids" {
  description = "A list of VPC subnet IDs"
  type        = list(string)
  default     = []
}

# DB parameter group
variable "create_db_parameter_group" {
  description = "Whether to create a database parameter group"
  type        = bool
  default     = true
}

variable "parameter_group_name" {
  description = "Name of the DB parameter group to associate or create"
  type        = string
  default     = null
}

variable "parameter_group_use_name_prefix" {
  description = "Determines whether to use `parameter_group_name` as is or create a unique name beginning with the `parameter_group_name` as the prefix"
  type        = bool
  default     = true
}

variable "parameter_group_description" {
  description = "Description of the DB parameter group to create"
  type        = string
  default     = null
}

variable "family" {
  description = "The family of the DB parameter group"
  type        = string
  default     = null
}

variable "parameters" {
  description = "A list of DB parameters (map) to apply"
  type        = list(map(string))
  default     = []
}

# DB option group
variable "create_db_option_group" {
  description = "Create a database option group"
  type        = bool
  default     = true
}

variable "option_group_name" {
  description = "Name of the option group"
  type        = string
  default     = null
}

variable "option_group_use_name_prefix" {
  description = "Determines whether to use `option_group_name` as is or create a unique name beginning with the `option_group_name` as the prefix"
  type        = bool
  default     = true
}

variable "option_group_description" {
  description = "The description of the option group"
  type        = string
  default     = null
}

variable "major_engine_version" {
  description = "Specifies the major version of the engine that this option group should be associated with"
  type        = string
  default     = null
}

variable "options" {
  description = "A list of Options to apply"
  type        = any
  default     = []
}

variable "create_db_instance" {
  description = "Whether to create a database instance"
  type        = bool
  default     = true
}

variable "timezone" {
  description = "Time zone of the DB instance. timezone is currently only supported by Microsoft SQL Server. The timezone can only be set on creation. See MSSQL User Guide for more information"
  type        = string
  default     = null
}

variable "character_set_name" {
  description = "The character set name to use for DB encoding in Oracle instances. This can't be changed. See Oracle Character Sets Supported in Amazon RDS and Collations and Character Sets for Microsoft SQL Server for more information. This can only be set on creation"
  type        = string
  default     = null
}

variable "nchar_character_set_name" {
  description = "The national character set is used in the NCHAR, NVARCHAR2, and NCLOB data types for Oracle instances. This can't be changed."
  type        = string
  default     = null
}

variable "enabled_cloudwatch_logs_exports" {
  description = "List of log types to enable for exporting to CloudWatch logs. If omitted, no logs will be exported. Valid values (depending on engine): alert, audit, error, general, listener, slowquery, trace, postgresql (PostgreSQL), upgrade (PostgreSQL)"
  type        = list(string)
  default     = []
}

variable "timeouts" {
  description = "Updated Terraform resource management timeouts. Applies to `aws_db_instance` in particular to permit resource management times"
  type        = map(string)
  default     = {}
}

variable "option_group_timeouts" {
  description = "Define maximum timeout for deletion of `aws_db_option_group` resource"
  type        = map(string)
  default     = {}
}

variable "deletion_protection" {
  description = "The database can't be deleted when this value is set to true"
  type        = bool
  default     = false
}

variable "performance_insights_enabled" {
  description = "Specifies whether Performance Insights are enabled"
  type        = bool
  default     = false
}

variable "performance_insights_retention_period" {
  description = "The amount of time in days to retain Performance Insights data. Valid values are `7`, `731` (2 years) or a multiple of `31`"
  type        = number
  default     = 7
}

variable "performance_insights_kms_key_id" {
  description = "The ARN for the KMS key to encrypt Performance Insights data"
  type        = string
  default     = null
}

variable "max_allocated_storage" {
  description = "Specifies the value for Storage Autoscaling"
  type        = number
  default     = 0
}

variable "ca_cert_identifier" {
  description = "Specifies the identifier of the CA certificate for the DB instance"
  type        = string
  default     = null
}

variable "delete_automated_backups" {
  description = "Specifies whether to remove automated backups immediately after the DB instance is deleted"
  type        = bool
  default     = true
}

variable "network_type" {
  description = "The type of network stack to use"
  type        = string
  default     = null
}

################################################################################
# CloudWatch Log Group
################################################################################

variable "create_cloudwatch_log_group" {
  description = "Determines whether a CloudWatch log group is created for each `enabled_cloudwatch_logs_exports`"
  type        = bool
  default     = false
}

variable "cloudwatch_log_group_retention_in_days" {
  description = "The number of days to retain CloudWatch logs for the DB instance"
  type        = number
  default     = 7
}

variable "cloudwatch_log_group_kms_key_id" {
  description = "The ARN of the KMS Key to use when encrypting log data"
  type        = string
  default     = null
}

################################################################################
# DB Instance Role Association
################################################################################

variable "db_instance_role_associations" {
  description = "A map of DB instance supported feature name to role association ARNs."
  type        = map(any)
  default     = {}
}

################################################################################
# Managed Secret Rotation
################################################################################

variable "manage_master_user_password_rotation" {
  description = "Whether to manage the master user password rotation. By default, false on creation, rotation is managed by RDS. Setting this value to false after previously having been set to true will disable automatic rotation."
  type        = bool
  default     = false
}

variable "master_user_password_rotate_immediately" {
  description = "Specifies whether to rotate the secret immediately or wait until the next scheduled rotation window."
  type        = bool
  default     = null
}

variable "master_user_password_rotation_automatically_after_days" {
  description = "Specifies the number of days between automatic scheduled rotations of the secret. Either automatically_after_days or schedule_expression must be specified."
  type        = number
  default     = null
}

variable "master_user_password_rotation_duration" {
  description = "The length of the rotation window in hours. For example, 3h for a three hour window."
  type        = string
  default     = null
}

variable "master_user_password_rotation_schedule_expression" {
  description = "A cron() or rate() expression that defines the schedule for rotating your secret. Either automatically_after_days or schedule_expression must be specified."
  type        = string
  default     = null
}

################################################################################
# Security Groups - SubModule variables
################################################################################
variable "sg_name" {
  description = "Name of security group"
  type        = string
  default     = null
}

variable "sg_vpc_id" {
  description = "ID of the VPC where to create security group"
  type        = string
  default     = null
}

variable "ingress_with_cidr_blocks" {
  description = "List of ingress rules to create where 'cidr_blocks' is used"
  type        = list(map(string))
  default     = []
}

variable "egress_with_cidr_blocks" {
  description = "List of egress rules to create where 'cidr_blocks' is used	"
  type        = list(map(string))
  default     = []
}

variable "sg_tags" {
  description = "A mapping of tags to assign to security group."
  type        = map(string)
  default     = {}
}

################################################################################
# Route 53 - SubModule variables
################################################################################
variable "create_record" {
  description = "Boolean value to create CNAME route53 DNS record in the given hosted zone"
  type        = string
  default     = false
}

variable "zone_name" {
  description = "Name of DNS zone"
  type        = string
  default     = null
}

variable "record_name" {
  description = "Name of DNS subdomain to use for the CNAME record"
  type        = string
  default     = null
}

variable "record_ttl" {
  description = "The TTL of the record."
  type        = string
  default     = null
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds_serverless_cluster\main.tf
/===============================================================================

resource "random_password" "password" {
  length = 16
}

locals {
  conn_data = merge(
    var.connection_data,
    {
      password = random_password.password.result
    }
  )
}

resource "aws_security_group" "cluster_security_group" {
  name        = "secg-${var.project}-${var.environment}-database"
  description = "${var.project}-${var.environment} database security group"
  ingress {
    protocol    = "tcp"
    from_port   = local.conn_data.port
    to_port     = local.conn_data.port
    cidr_blocks = ["0.0.0.0/0"]
  }
  vpc_id = var.vpc_id
}

resource "aws_rds_cluster_parameter_group" "cluster_parameter_group" {
  name        = "${var.project}-${var.environment}-parameter-group"
  family      = "aurora-postgresql15"
  description = "${var.project}-${var.environment} db parameter group"
  dynamic "parameter" {
    for_each = var.parameters
    content {
      name         = parameter.value["name"]
      value        = parameter.value["value"]
      apply_method = try(parameter.value["apply_method"], null)
    }
  }
}

resource "aws_db_subnet_group" "subnet_group" {
  name        = "${var.project}-${var.environment}-subnet-group"
  description = "${var.project}-${var.environment} db subnet group"
  subnet_ids  = var.subnet_ids
}

resource "aws_secretsmanager_secret" "connection" {
  name_prefix             = "scm-${var.project}-${var.environment}-db-connection"
  recovery_window_in_days = 7
}

resource "aws_secretsmanager_secret_version" "this" {
  secret_id = aws_secretsmanager_secret.connection.id
  secret_string = jsonencode(
    merge(
      local.conn_data,
      {
        host            = aws_rds_cluster.aurora_cluster.endpoint
        reader_endpoint = aws_rds_cluster.aurora_cluster.reader_endpoint
        engine          = aws_rds_cluster.aurora_cluster.engine
        engine_version  = aws_rds_cluster.aurora_cluster.engine_version_actual
      }
    )
  )
}

resource "aws_rds_cluster" "aurora_cluster" {
  availability_zones              = var.availability_zones
  backup_retention_period         = var.backup_retention_period
  copy_tags_to_snapshot           = true
  database_name                   = local.conn_data.dbname
  cluster_identifier              = "db-${var.project}-${var.environment}-cluster"
  db_cluster_parameter_group_name = aws_rds_cluster_parameter_group.cluster_parameter_group.id
  db_subnet_group_name            = aws_db_subnet_group.subnet_group.id
  deletion_protection             = var.deletion_protection
  final_snapshot_identifier       = "${var.project}-${var.environment}-final-snapshot"
  enabled_cloudwatch_logs_exports = [
    "postgresql"
  ]
  enable_http_endpoint = false
  engine               = "aurora-postgresql"
  engine_mode          = "provisioned"
  engine_version       = var.engine_version
  master_username      = local.conn_data.username
  master_password      = local.conn_data.password
  port                 = local.conn_data.port
  serverlessv2_scaling_configuration {
    min_capacity = var.min_capacity
    max_capacity = var.max_capacity
  }
  storage_encrypted = true
  vpc_security_group_ids = [
    aws_security_group.cluster_security_group.id
  ]
  snapshot_identifier = try(var.db_cluster_snapshot_identifier, null)
  lifecycle {
    ignore_changes = [snapshot_identifier]
  }
}

resource "aws_rds_cluster_instance" "instance" {
  count              = var.instances_count
  identifier         = "db-${var.project}-${var.environment}-instance-${format("%02s", count.index + 1)}"
  cluster_identifier = aws_rds_cluster.aurora_cluster.id
  instance_class     = "db.serverless"
  engine             = aws_rds_cluster.aurora_cluster.engine
  engine_version     = aws_rds_cluster.aurora_cluster.engine_version
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds_serverless_cluster\outputs.tf
/===============================================================================

output "connection_secret_id" {
  value = aws_secretsmanager_secret.connection.id
}

output "connection_secret_arn" {
  value = aws_secretsmanager_secret.connection.arn
}

output "cluster_security_group_id" {
  value = aws_security_group.cluster_security_group.id
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds_serverless_cluster\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\rds_serverless_cluster\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
}

variable "environment" {
  description = "Project's environment"
  type        = string
}

variable "min_capacity" {
  description = "DB min capacity"
  type        = number
}

variable "max_capacity" {
  description = "DB min capacity"
  type        = number
}

variable "backup_retention_period" {
  description = "Backup retention period"
  type        = number
}

variable "engine_version" {
  description = "DB engine version"
  type        = number
}

variable "instances_count" {
  description = "DB instances count"
  type        = number
  default     = 1
}

variable "connection_data" {
  description = "DB Connection data"
  type        = object({ username = string, port = number, dbname = string })
}

variable "parameters" {
  description = "DB parameters"
  type        = list(any)
}

variable "availability_zones" {
  description = "Availability zones"
  type        = list(string)
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}

variable "subnet_ids" {
  description = "Subnets ids"
  type        = list(string)
}

variable "deletion_protection" {
  description = "Deletion protection"
  type        = bool
  default     = false
}

variable "db_cluster_snapshot_identifier" {
  description = "DB Cluster Snapshot Id"
  type        = string
  default     = null
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\route53\main.tf
/===============================================================================

resource "aws_route53_zone" "this" {
  name = var.hosted_zone_name
  tags = {
    Name = "dns-${var.project}-${var.environment}-${var.hosted_zone_name}"
  }
}


resource "aws_route53_record" "this" {
  zone_id = var.parent_hosted_zone_id
  name    = var.hosted_zone_name
  type    = "NS"
  ttl     = "30"
  records = aws_route53_zone.this.name_servers
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\route53\outputs.tf
/===============================================================================

output "zone_id" {
  description = "Hosted zone Id"
  value       = aws_route53_zone.this.zone_id
}

output "zone_name" {
  description = "Hosted zone name"
  value       = var.hosted_zone_name
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\route53\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\route53\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 6 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 6 no special characters with no numbers and whitespaces"
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "hosted_zone_name" {
  description = "Hosted zone name"
  type        = string
}

variable "parent_hosted_zone_id" {
  description = "Parent hosted zone id"
  type        = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\s3\main.tf
/===============================================================================

module "s3-bucket" {
  source  = "terraform-aws-modules/s3-bucket/aws"
  version = "4.2.2"

  for_each = var.items

  acceleration_status                        = try(each.value.acceleration_status, var.defaults.acceleration_status, null)
  access_log_delivery_policy_source_accounts = try(each.value.access_log_delivery_policy_source_accounts, var.defaults.access_log_delivery_policy_source_accounts, [])
  access_log_delivery_policy_source_buckets  = try(each.value.access_log_delivery_policy_source_buckets, var.defaults.access_log_delivery_policy_source_buckets, [])
  acl                                        = try(each.value.acl, var.defaults.acl, null)
  allowed_kms_key_arn                        = try(each.value.allowed_kms_key_arn, var.defaults.allowed_kms_key_arn, null)
  analytics_configuration                    = try(each.value.analytics_configuration, var.defaults.analytics_configuration, {})
  analytics_self_source_destination          = try(each.value.analytics_self_source_destination, var.defaults.analytics_self_source_destination, false)
  analytics_source_account_id                = try(each.value.analytics_source_account_id, var.defaults.analytics_source_account_id, null)
  analytics_source_bucket_arn                = try(each.value.analytics_source_bucket_arn, var.defaults.analytics_source_bucket_arn, null)
  attach_access_log_delivery_policy          = try(each.value.attach_access_log_delivery_policy, var.defaults.attach_access_log_delivery_policy, false)
  attach_analytics_destination_policy        = try(each.value.attach_analytics_destination_policy, var.defaults.attach_analytics_destination_policy, false)
  attach_deny_incorrect_encryption_headers   = try(each.value.attach_deny_incorrect_encryption_headers, var.defaults.attach_deny_incorrect_encryption_headers, false)
  attach_deny_incorrect_kms_key_sse          = try(each.value.attach_deny_incorrect_kms_key_sse, var.defaults.attach_deny_incorrect_kms_key_sse, false)
  attach_deny_insecure_transport_policy      = try(each.value.attach_deny_insecure_transport_policy, var.defaults.attach_deny_insecure_transport_policy, false)
  attach_deny_unencrypted_object_uploads     = try(each.value.attach_deny_unencrypted_object_uploads, var.defaults.attach_deny_unencrypted_object_uploads, false)
  attach_elb_log_delivery_policy             = try(each.value.attach_elb_log_delivery_policy, var.defaults.attach_elb_log_delivery_policy, false)
  attach_inventory_destination_policy        = try(each.value.attach_inventory_destination_policy, var.defaults.attach_inventory_destination_policy, false)
  attach_lb_log_delivery_policy              = try(each.value.attach_lb_log_delivery_policy, var.defaults.attach_lb_log_delivery_policy, false)
  attach_policy                              = try(each.value.attach_policy, var.defaults.attach_policy, false)
  attach_public_policy                       = try(each.value.attach_public_policy, var.defaults.attach_public_policy, true)
  attach_require_latest_tls_policy           = try(each.value.attach_require_latest_tls_policy, var.defaults.attach_require_latest_tls_policy, false)
  block_public_acls                          = try(each.value.block_public_acls, var.defaults.block_public_acls, true)
  block_public_policy                        = try(each.value.block_public_policy, var.defaults.block_public_policy, true)
  bucket                                     = try(each.value.bucket, var.defaults.bucket, null)
  bucket_prefix                              = try(each.value.bucket_prefix, var.defaults.bucket_prefix, null)
  control_object_ownership                   = try(each.value.control_object_ownership, var.defaults.control_object_ownership, false)
  cors_rule                                  = try(each.value.cors_rule, var.defaults.cors_rule, [])
  create_bucket                              = try(each.value.create_bucket, var.defaults.create_bucket, true)
  expected_bucket_owner                      = try(each.value.expected_bucket_owner, var.defaults.expected_bucket_owner, null)
  force_destroy                              = try(each.value.force_destroy, var.defaults.force_destroy, false)
  grant                                      = try(each.value.grant, var.defaults.grant, [])
  ignore_public_acls                         = try(each.value.ignore_public_acls, var.defaults.ignore_public_acls, true)
  intelligent_tiering                        = try(each.value.intelligent_tiering, var.defaults.intelligent_tiering, {})
  inventory_configuration                    = try(each.value.inventory_configuration, var.defaults.inventory_configuration, {})
  inventory_self_source_destination          = try(each.value.inventory_self_source_destination, var.defaults.inventory_self_source_destination, false)
  inventory_source_account_id                = try(each.value.inventory_source_account_id, var.defaults.inventory_source_account_id, null)
  inventory_source_bucket_arn                = try(each.value.inventory_source_bucket_arn, var.defaults.inventory_source_bucket_arn, null)
  lifecycle_rule                             = try(each.value.lifecycle_rule, var.defaults.lifecycle_rule, [])
  logging                                    = try(each.value.logging, var.defaults.logging, {})
  metric_configuration                       = try(each.value.metric_configuration, var.defaults.metric_configuration, [])
  object_lock_configuration                  = try(each.value.object_lock_configuration, var.defaults.object_lock_configuration, {})
  object_lock_enabled                        = try(each.value.object_lock_enabled, var.defaults.object_lock_enabled, false)
  object_ownership                           = try(each.value.object_ownership, var.defaults.object_ownership, "BucketOwnerEnforced")
  owner                                      = try(each.value.owner, var.defaults.owner, {})
  policy                                     = try(each.value.policy, var.defaults.policy, null)
  putin_khuylo                               = try(each.value.putin_khuylo, var.defaults.putin_khuylo, true)
  replication_configuration                  = try(each.value.replication_configuration, var.defaults.replication_configuration, {})
  request_payer                              = try(each.value.request_payer, var.defaults.request_payer, null)
  restrict_public_buckets                    = try(each.value.restrict_public_buckets, var.defaults.restrict_public_buckets, true)
  server_side_encryption_configuration       = try(each.value.server_side_encryption_configuration, var.defaults.server_side_encryption_configuration, {})
  transition_default_minimum_object_size     = try(each.value.transition_default_minimum_object_size, var.defaults.transition_default_minimum_object_size, null)
  versioning                                 = try(each.value.versioning, var.defaults.versioning, {})
  website                                    = try(each.value.website, var.defaults.website, {})

  tags = try(each.value.tags, var.defaults.tags, {})
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\s3\outputs.tf
/===============================================================================

output "s3_bucket_id" {
  description = "The names of the buckets."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_id }
}

output "s3_bucket_arn" {
  description = "The ARNs of the buckets. Will be in the format arn:aws:s3:::bucketname."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_arn }
}

output "s3_bucket_bucket_domain_name" {
  description = "The domain names of the buckets. Format: bucketname.s3.amazonaws.com."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_bucket_domain_name }
}

output "s3_bucket_bucket_regional_domain_name" {
  description = "The region-specific domain names of the buckets, used to prevent redirect issues with CloudFront."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_bucket_regional_domain_name }
}

output "s3_bucket_hosted_zone_id" {
  description = "The Route 53 Hosted Zone IDs for each bucket's region."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_hosted_zone_id }
}

output "s3_bucket_lifecycle_configuration_rules" {
  description = "The lifecycle rules of the buckets. If not configured, this will be an empty string."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_lifecycle_configuration_rules }
}

output "s3_bucket_policy" {
  description = "The policies of the buckets. If not configured, this will be an empty string."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_policy }
}

output "s3_bucket_region" {
  description = "The AWS regions where the buckets reside."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_region }
}

output "s3_bucket_website_endpoint" {
  description = "The website endpoints for the buckets. If not configured, this will be an empty string."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_website_endpoint }
}

output "s3_bucket_website_domain" {
  description = "The domains of the website endpoints, useful for creating Route 53 alias records."
  value       = { for key, v in module.s3-bucket : key => v.s3_bucket_website_domain }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\s3\variables.tf
/===============================================================================

variable "items" {
  type    = any
  default = {}
}

variable "defaults" {
  type = any
  default = {
    create_bucket                              = true
    attach_elb_log_delivery_policy             = false
    attach_lb_log_delivery_policy              = false
    attach_access_log_delivery_policy          = false
    attach_deny_insecure_transport_policy      = false
    attach_require_latest_tls_policy           = false
    attach_policy                              = false
    attach_public_policy                       = true
    attach_inventory_destination_policy        = false
    attach_analytics_destination_policy        = false
    attach_deny_incorrect_encryption_headers   = false
    attach_deny_incorrect_kms_key_sse          = false
    allowed_kms_key_arn                        = null
    attach_deny_unencrypted_object_uploads     = false
    bucket                                     = null
    bucket_prefix                              = null
    acl                                        = null
    policy                                     = null
    tags                                       = {}
    force_destroy                              = false
    acceleration_status                        = null
    request_payer                              = null
    website                                    = {}
    cors_rule                                  = []
    versioning                                 = {}
    logging                                    = {}
    access_log_delivery_policy_source_buckets  = []
    access_log_delivery_policy_source_accounts = []
    grant                                      = []
    owner                                      = {}
    expected_bucket_owner                      = null
    lifecycle_rule                             = []
    replication_configuration                  = {}
    server_side_encryption_configuration       = {}
    intelligent_tiering                        = {}
    object_lock_configuration                  = {}
    metric_configuration                       = []
    inventory_configuration                    = {}
    inventory_source_account_id                = null
    inventory_source_bucket_arn                = null
    inventory_self_source_destination          = false
    analytics_configuration                    = {}
    analytics_source_account_id                = null
    analytics_source_bucket_arn                = null
    analytics_self_source_destination          = false
    object_lock_enabled                        = false
    block_public_acls                          = true
    block_public_policy                        = true
    ignore_public_acls                         = true
    restrict_public_buckets                    = true
    control_object_ownership                   = false
    object_ownership                           = "BucketOwnerEnforced"
    region                                     = null
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\s3\versions.tf
/===============================================================================

terraform {
  required_version = ">= 1.5"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.70"
    }
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\secrets_manager\main.tf
/===============================================================================


################################################################################
# Secret
################################################################################

resource "aws_secretsmanager_secret" "this" {
  count = var.create ? 1 : 0

  description                    = var.description
  force_overwrite_replica_secret = var.force_overwrite_replica_secret
  kms_key_id                     = var.kms_key_id
  name                           = var.name
  name_prefix                    = var.name_prefix
  recovery_window_in_days        = var.recovery_window_in_days

  dynamic "replica" {
    for_each = var.replica

    content {
      kms_key_id = try(replica.value.kms_key_id, null)
      region     = try(replica.value.region, replica.key)
    }
  }

  tags = var.tags
}

################################################################################
# Policy
################################################################################

data "aws_iam_policy_document" "this" {
  count = var.create && var.create_policy ? 1 : 0

  source_policy_documents   = var.source_policy_documents
  override_policy_documents = var.override_policy_documents

  dynamic "statement" {
    for_each = var.policy_statements

    content {
      sid           = try(statement.value.sid, null)
      actions       = try(statement.value.actions, null)
      not_actions   = try(statement.value.not_actions, null)
      effect        = try(statement.value.effect, null)
      resources     = try(statement.value.resources, null)
      not_resources = try(statement.value.not_resources, null)

      dynamic "principals" {
        for_each = try(statement.value.principals, [])

        content {
          type        = principals.value.type
          identifiers = principals.value.identifiers
        }
      }

      dynamic "not_principals" {
        for_each = try(statement.value.not_principals, [])

        content {
          type        = not_principals.value.type
          identifiers = not_principals.value.identifiers
        }
      }

      dynamic "condition" {
        for_each = try(statement.value.conditions, [])

        content {
          test     = condition.value.test
          values   = condition.value.values
          variable = condition.value.variable
        }
      }
    }
  }
}

resource "aws_secretsmanager_secret_policy" "this" {
  count = var.create && var.create_policy ? 1 : 0

  secret_arn          = aws_secretsmanager_secret.this[0].arn
  policy              = data.aws_iam_policy_document.this[0].json
  block_public_policy = var.block_public_policy
}

################################################################################
# Version
################################################################################

resource "aws_secretsmanager_secret_version" "this" {
  count = var.create && !(var.enable_rotation || var.ignore_secret_changes) ? 1 : 0

  secret_id      = aws_secretsmanager_secret.this[0].id
  secret_string  = var.create_random_password ? random_password.this[0].result : var.secret_string
  secret_binary  = var.secret_binary
  version_stages = var.version_stages
}

resource "aws_secretsmanager_secret_version" "ignore_changes" {
  count = var.create && (var.enable_rotation || var.ignore_secret_changes) ? 1 : 0

  secret_id      = aws_secretsmanager_secret.this[0].id
  secret_string  = var.create_random_password ? random_password.this[0].result : var.secret_string
  secret_binary  = var.secret_binary
  version_stages = var.version_stages

  lifecycle {
    ignore_changes = [
      secret_string,
      secret_binary,
      version_stages,
    ]
  }
}

resource "random_password" "this" {
  count = var.create && var.create_random_password ? 1 : 0

  length           = var.random_password_length
  special          = true
  override_special = var.random_password_override_special
}

################################################################################
# Rotation
################################################################################

resource "aws_secretsmanager_secret_rotation" "this" {
  count = var.create && var.enable_rotation ? 1 : 0

  rotation_lambda_arn = var.rotation_lambda_arn

  dynamic "rotation_rules" {
    for_each = [var.rotation_rules]

    content {
      automatically_after_days = try(rotation_rules.value.automatically_after_days, null)
      duration                 = try(rotation_rules.value.duration, null)
      schedule_expression      = try(rotation_rules.value.schedule_expression, null)
    }
  }

  secret_id = aws_secretsmanager_secret.this[0].id
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\secrets_manager\outputs.tf
/===============================================================================

################################################################################
# Secret
################################################################################

output "secret_arn" {
  description = "The ARN of the secret"
  value       = try(aws_secretsmanager_secret.this[0].arn, null)
}

output "secret_id" {
  description = "The ID of the secret"
  value       = try(aws_secretsmanager_secret.this[0].id, null)
}

output "secret_name" {
  description = "The name of the secret"
  value       = try(aws_secretsmanager_secret.this[0].name, null)
}

output "secret_replica" {
  description = "Attributes of the replica created"
  value       = try(aws_secretsmanager_secret.this[0].replica, null)
}

output "secret_string" {
  description = "The secret string"
  sensitive   = true
  value       = try(aws_secretsmanager_secret_version.this[0].secret_string, aws_secretsmanager_secret_version.ignore_changes[0].secret_string, null)
}

output "secret_binary" {
  description = "The secret binary"
  sensitive   = true
  value       = try(aws_secretsmanager_secret_version.this[0].secret_binary, aws_secretsmanager_secret_version.ignore_changes[0].secret_binary, null)
}

################################################################################
# Version
################################################################################

output "secret_version_id" {
  description = "The unique identifier of the version of the secret"
  value       = try(aws_secretsmanager_secret_version.this[0].version_id, aws_secretsmanager_secret_version.ignore_changes[0].version_id, null)
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\secrets_manager\variables.tf
/===============================================================================

variable "create" {
  description = "Determines whether resources will be created (affects all resources)"
  type        = bool
  default     = true
}

variable "tags" {
  description = "A map of tags to add to all resources"
  type        = map(string)
  default     = {}
}

################################################################################
# Secret
################################################################################

variable "description" {
  description = "A description of the secret"
  type        = string
  default     = null
}

variable "force_overwrite_replica_secret" {
  description = "Accepts boolean value to specify whether to overwrite a secret with the same name in the destination Region"
  type        = bool
  default     = null
}

variable "kms_key_id" {
  description = "ARN or Id of the AWS KMS key to be used to encrypt the secret values in the versions stored in this secret. If you need to reference a CMK in a different account, you can use only the key ARN. If you don't specify this value, then Secrets Manager defaults to using the AWS account's default KMS key (the one named `aws/secretsmanager`"
  type        = string
  default     = null
}

variable "name" {
  description = "Friendly name of the new secret. The secret name can consist of uppercase letters, lowercase letters, digits, and any of the following characters: `/_+=.@-`"
  type        = string
  default     = null
}

variable "name_prefix" {
  description = "Creates a unique name beginning with the specified prefix"
  type        = string
  default     = null
}

variable "recovery_window_in_days" {
  description = "Number of days that AWS Secrets Manager waits before it can delete the secret. This value can be `0` to force deletion without recovery or range from `7` to `30` days. The default value is `30`"
  type        = number
  default     = null
}

variable "replica" {
  description = "Configuration block to support secret replication"
  type        = map(any)
  default     = {}
}

################################################################################
# Policy
################################################################################

variable "create_policy" {
  description = "Determines whether a policy will be created"
  type        = bool
  default     = false
}

variable "source_policy_documents" {
  description = "List of IAM policy documents that are merged together into the exported document. Statements must have unique `sid`s"
  type        = list(string)
  default     = []
}

variable "override_policy_documents" {
  description = "List of IAM policy documents that are merged together into the exported document. In merging, statements with non-blank `sid`s will override statements with the same `sid`"
  type        = list(string)
  default     = []
}

variable "policy_statements" {
  description = "A map of IAM policy [statements](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy_document#statement) for custom permission usage"
  type        = map(any)
  default     = {}
}

variable "block_public_policy" {
  description = "Makes an optional API call to Zelkova to validate the Resource Policy to prevent broad access to your secret"
  type        = bool
  default     = null
}

################################################################################
# Version
################################################################################

variable "ignore_secret_changes" {
  description = "Determines whether or not Terraform will ignore changes made externally to `secret_string` or `secret_binary`. Changing this value after creation is a destructive operation"
  type        = bool
  default     = false
}

variable "secret_string" {
  description = "Specifies text data that you want to encrypt and store in this version of the secret. This is required if `secret_binary` is not set"
  type        = string
  default     = null
}

variable "secret_binary" {
  description = "Specifies binary data that you want to encrypt and store in this version of the secret. This is required if `secret_string` is not set. Needs to be encoded to base64"
  type        = string
  default     = null
}

variable "version_stages" {
  description = "Specifies a list of staging labels that are attached to this version of the secret. A staging label must be unique to a single version of the secret"
  type        = list(string)
  default     = null
}

variable "create_random_password" {
  description = "Determines whether a random password will be generated"
  type        = bool
  default     = false
}

variable "random_password_length" {
  description = "The length of the generated random password"
  type        = number
  default     = 32
}

variable "random_password_override_special" {
  description = "Supply your own list of special characters to use for string generation. This overrides the default character list in the special argument"
  type        = string
  default     = "!@#$%&*()-_=+[]{}<>:?"
}

################################################################################
# Rotation
################################################################################

variable "enable_rotation" {
  description = "Determines whether secret rotation is enabled"
  type        = bool
  default     = false
}

variable "rotation_lambda_arn" {
  description = "Specifies the ARN of the Lambda function that can rotate the secret"
  type        = string
  default     = ""
}

variable "rotation_rules" {
  description = "A structure that defines the rotation configuration for this secret"
  type        = map(any)
  default     = {}
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\secrets_manager\versions.tf
/===============================================================================

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = ">= 3.0"
    }
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\service_discovery_namespace\main.tf
/===============================================================================

resource "aws_service_discovery_private_dns_namespace" "this" {
  name        = var.name
  description = "Private dns namespace ${var.name}"
  vpc         = var.vpc_id
  tags = {
    Name = "dsrv-${var.project}-${var.environment}-namespace"
  }
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\service_discovery_namespace\outputs.tf
/===============================================================================

output "namespace_name" {
  value = var.name
}

output "namespace_id" {
  value = aws_service_discovery_private_dns_namespace.this.id
}

output "namespace_arn" {
  value = aws_service_discovery_private_dns_namespace.this.arn
}

output "namespace_hostedzone_id" {
  value = aws_service_discovery_private_dns_namespace.this.hosted_zone
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\service_discovery_namespace\providers.tf
/===============================================================================

# Provider Version Constraints
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\service_discovery_namespace\variables.tf
/===============================================================================

variable "project" {
  description = "Project's name"
  type        = string
  validation {
    condition     = length(var.project) >= 3 && length(var.project) <= 6 && can(regex("^[a-z]+$", var.project))
    error_message = "The project's name must to have between 3 and 6 no special characters with no numbers and whitespaces"
  }
}

variable "environment" {
  description = "Project's environment"
  type        = string
  default     = "dev"
  validation {
    condition     = contains(["dev", "uat", "pdn"], var.environment)
    error_message = "The project's environment must to be dev, uat or pdn."
  }
}

variable "name" {
  description = "Private dns namespace"
  type        = string
}

variable "vpc_id" {
  description = "VPC Id"
  type        = string
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns\main.tf
/===============================================================================

### Creación del SNS Topic ###

resource "aws_sns_topic" "this" {
  name              = var.name
  display_name      = var.display_name
  fifo_topic        = var.fifo_topic
  content_based_deduplication = var.content_based_deduplication
  kms_master_key_id = var.kms_master_key_id
  tags              = var.tags
}

### Politica del topico ###

resource "aws_sns_topic_policy" "this" {
  count  = var.create_policy ? 1 : 0
  arn    = aws_sns_topic.this.arn
  policy = data.aws_iam_policy_document.sns_policy[0].json
}

data "aws_iam_policy_document" "sns_policy" {
  count = var.create_policy ? 1 : 0

  dynamic "statement" {
    for_each = var.policy_statements

    content {
      sid     = try(statement.value.sid, null)
      effect  = try(statement.value.effect, "Allow")
      actions = try(statement.value.actions, ["sns:Publish"])
      resources = [aws_sns_topic.this.arn]

      dynamic "principals" {
        for_each = try(statement.value.principals, [])

        content {
          type        = principals.value.type
          identifiers = principals.value.identifiers
        }
      }

      dynamic "condition" {
        for_each = try(statement.value.conditions, [])

        content {
          test     = condition.value.test
          values   = condition.value.values
          variable = condition.value.variable
        }
      }
    }
  }
}


### Suscripciones al topic ###

resource "aws_sns_topic_subscription" "this" {
  for_each = { for s in var.subscriptions : s.endpoint => s }

  topic_arn = aws_sns_topic.this.arn
  protocol  = each.value.protocol
  endpoint  = each.value.endpoint
  raw_message_delivery = try(each.value.raw_message_delivery, null)
  filter_policy        = try(each.value.filter_policy, null)
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns\outputs.tf
/===============================================================================

output "topic_arn" {
  description = "ARN of the SNS topic"
  value       = aws_sns_topic.this.arn
}

output "topic_name" {
  description = "Name of the SNS topic"
  value       = aws_sns_topic.this.name
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns\variables.tf
/===============================================================================

variable "name" {
  description = "SNS topic name"
  type        = string
}

variable "display_name" {
  description = "Display name for the SNS topic"
  type        = string
  default     = null
}

variable "fifo_topic" {
  description = "Whether the topic is FIFO"
  type        = bool
  default     = false
}

variable "content_based_deduplication" {
  description = "Enable content-based deduplication for FIFO"
  type        = bool
  default     = false
}

variable "kms_master_key_id" {
  description = "KMS key ARN or alias for encryption"
  type        = string
  default     = null
}

variable "tags" {
  description = "Tags to apply to the SNS topic"
  type        = map(string)
  default     = {}
}

variable "create_policy" {
  description = "Whether to attach a custom policy to the topic"
  type        = bool
  default     = false
}

variable "policy_statements" {
  description = "List of IAM policy statements"
  type        = list(any)
  default     = []
}

variable "subscriptions" {
  description = "List of subscriptions"
  type = list(object({
    protocol              = string
    endpoint              = string
    raw_message_delivery  = optional(bool)
    filter_policy         = optional(string)
  }))
  default = []
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns\versions.tf
/===============================================================================

terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns_subscriptions\main.tf
/===============================================================================

resource "aws_sns_topic_subscription" "this" {
  topic_arn = var.topic_arn
  protocol  = var.protocol
  endpoint  = var.endpoint

  raw_message_delivery = var.raw_message_delivery

  filter_policy = length(var.filter_policy) > 0 ? jsonencode(var.filter_policy) : null
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns_subscriptions\outputs.tf
/===============================================================================

output "subscription_arn" {
  description = "ARN de la suscripción SNS creada"
  value       = aws_sns_topic_subscription.this.arn
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns_subscriptions\variables.tf
/===============================================================================

variable "topic_arn" {
  description = "ARN del SNS al que se suscribirá el endpoint"
  type        = string
}

variable "protocol" {
  description = "Protocolo de la suscripción SNS (lambda, sqs, email, http, https, sms)"
  type        = string
}

variable "endpoint" {
  description = "Endpoint de destino de la suscripción SNS (ARN de Lambda/SQS, correo, URL, etc)"
  type        = string
}

variable "raw_message_delivery" {
  description = "Si se habilita la entrega de mensajes sin envolver (solo para SQS y HTTP/S)"
  type        = bool
  default     = false
}

variable "filter_policy" {
  description = "Política de filtro para la suscripción"
  type        = map(any)
  default     = {}
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sns_subscriptions\versions.tf
/===============================================================================

terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs\main.tf
/===============================================================================

resource "aws_sqs_queue" "this" {
  for_each = { for q in var.queues : q.name => q }

  name                       = "${each.value.name}${each.value.fifo ? ".fifo" : ""}"
  fifo_queue                 = each.value.fifo
  visibility_timeout_seconds = each.value.visibility_timeout
  message_retention_seconds  = each.value.message_retention
  delay_seconds              = each.value.delay_seconds
  max_message_size           = each.value.max_message_size
  receive_wait_time_seconds  = each.value.receive_wait_time

  redrive_policy = each.value.redrive_policy != null ? jsonencode({
  deadLetterTargetArn = each.value.redrive_policy.dead_letter_target_arn
  maxReceiveCount     = each.value.redrive_policy.max_receive_count
}) : null


  tags = merge({
    Project     = var.project,
    Environment = var.environment,
    Name        = "${each.value.name}${each.value.fifo ? ".fifo" : ""}"
  }, each.value.tags)
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs\outputs.tf
/===============================================================================

output "queue_urls" {
  description = "URL de las colas SQS creadas"
  value       = { for name, queue in aws_sqs_queue.this : name => queue.url }
}

output "queue_arns" {
  description = "ARN de las colas SQS creadas"
  value       = { for name, queue in aws_sqs_queue.this : name => queue.arn }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs\variables.tf
/===============================================================================

variable "queues" {
  description = "Lista de colas SQS a crear con su configuración."
  type = list(object({
    name                   = string
    fifo                   = optional(bool, false)
    visibility_timeout     = optional(number, 30)
    message_retention      = optional(number, 345600) # 4 días
    delay_seconds          = optional(number, 0)
    max_message_size       = optional(number, 262144)
    receive_wait_time      = optional(number, 0)
    redrive_policy         = optional(object({
      dead_letter_target_arn = string
      max_receive_count      = number
    }), null)
    tags                   = optional(map(string), {})
  }))
}

variable "project" {
  description = "Nombre del proyecto para tagging y nombre de recurso"
  type        = string
}

variable "environment" {
  description = "Ambiente (dev, uat, prod)"
  type        = string
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs\versions.tf
/===============================================================================

terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs_policy\main.tf
/===============================================================================

locals {
  policy_statements = flatten([
    var.allow_cross_account ? [
      {
        Sid      = "Allow-Root"
        Effect   = "Allow"
        Principal = {
          AWS = var.cross_account_principals
        }
        Action   = var.actions_root
        Resource = [var.queue_arn]
      }
    ] : [],
    var.allow_service ? [
      {
        Sid      = "Allow-Service-SendMessage"
        Effect   = "Allow"
        Principal = {
          Service = var.service_name
        }
        Action   = var.service_actions
        Resource = [var.queue_arn]
        Condition = {
          ArnEquals = {
            "aws:SourceArn" = var.service_source_arns
          }
        }
      }
    ] : []
  ])
}

resource "aws_sqs_queue_policy" "this" {

  queue_url = var.queue_url

  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = local.policy_statements
  })
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs_policy\outputs.tf
/===============================================================================

output "policy_id" {
  description = "ID de la política aplicada a cada SQS"
  value       = aws_sqs_queue_policy.this.id
}

output "policy_json" {
  description = "Política JSON aplicada a cada SQS"
  value       = aws_sqs_queue_policy.this.policy
}

output "queue_urls_with_policy" {
  description = "Lista de URLs de colas con política aplicada"
  value       = aws_sqs_queue_policy.this.queue_url
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs_policy\variables.tf
/===============================================================================

variable "queue_arn" {
  description = "ARN de las colas a las que aplicar la política"
  type        = string
}

variable "queue_url" {
  description = "URL de las colas a las que aplicar la política"
  type        = string
}

variable "allow_cross_account" {
  description = "Si habilita permisos cross-account (true/false)"
  type        = bool
  default     = false
}

variable "cross_account_principals" {
  description = "Lista de ARNs de cuentas cross-account si se habilita"
  type        = list(string)
  default     = []
}

variable "allow_service" {
  description = "Si habilita permisos a servicios (SNS, etc.)"
  type        = bool
  default     = false
}

variable "service_name" {
  description = "Nombre del servicio a permitir (por ejemplo: sns.amazonaws.com)"
  type        = string
  default     = ""
}

variable "service_actions" {
  description = "Lista de acciones permitidas para el servicio"
  type        = list(string)
  default     = ["sqs:SendMessage"]
}

variable "service_source_arns" {
  description = "Lista de ARNs de SNS u otros servicios que pueden enviar mensajes"
  type        = list(string)
  default     = []
}

variable "actions_root" {
  description = "Acciones que se permiten para root cross-account"
  type        = list(string)
  default     = ["sqs:SendMessage", "sqs:ReceiveMessage"]
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\sqs_policy\versions.tf
/===============================================================================

terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 4.0"
    }
  }
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ssm_parameter\main.tf
/===============================================================================

locals {
  ignore_value_changes_params = {
    for param in var.parameters : param.name => param if try(param.ignore_value_changes, false) == true
  }
  handle_value_changes_params = {
    for param in var.parameters : param.name => param if try(param.ignore_value_changes, false) == false
  }
}

resource "aws_ssm_parameter" "ignore_value_changes_param" {
  for_each        = local.ignore_value_changes_params
  name            = each.key
  type            = try(each.value.type, "SecureString")
  allowed_pattern = try(each.value.allowed_pattern, null)
  data_type       = try(each.value.data_type, null)
  description     = try(each.value.description, null)
  key_id          = try(each.value.key_id, null)
  tags            = try(each.value.tags, null)
  tier            = try(each.value.tier, null)
  value           = try(each.value.value, "CHANGE_ME")
  lifecycle {
    ignore_changes = [value]
  }
}

resource "aws_ssm_parameter" "handle_value_changes_param" {
  for_each        = local.handle_value_changes_params
  name            = each.key
  type            = try(each.value.type, "SecureString")
  allowed_pattern = try(each.value.allowed_pattern, null)
  data_type       = try(each.value.data_type, null)
  description     = try(each.value.description, null)
  key_id          = try(each.value.key_id, null)
  tags            = try(each.value.tags, null)
  tier            = try(each.value.tier, null)
  value           = try(each.value.value, "CHANGE_ME")
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ssm_parameter\outputs.tf
/===============================================================================

output "ignore_value_changes_param_arns" {
  value = [for param in aws_ssm_parameter.ignore_value_changes_param : param.arn]
}

output "handle_value_changes_param_arns" {
  value = [for param in aws_ssm_parameter.handle_value_changes_param : param.arn]
}


// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ssm_parameter\providers.tf
/===============================================================================

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.25"
    }
  }
  required_version = ">= 1.5"
}



// File: C:\Proyectos_software\Work\btg\Terraform\MURIC\devops-terraform-modules\ssm_parameter\variables.tf
/===============================================================================

variable "parameters" {
  description = "Parameters list"
  type        = any
}


